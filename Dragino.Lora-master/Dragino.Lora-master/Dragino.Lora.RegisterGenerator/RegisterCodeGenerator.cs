using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Text.RegularExpressions;
using System.Xml.Linq;

namespace Dragino.Lora.RegisterGenerator
{
    internal class RegisterCodeGenerator : IReferenceResolver
    {
        private readonly XDocument _registersXml;
        private readonly bool _verboseComments;

        private class EnumValue
        {
            public EnumValue(string name, byte value, bool isDefault, string description)
            {
                Name = name;
                Value = value;
                IsDefault = isDefault;
                Description = description;
            }

            public string Name { get; }

            public byte Value { get; }

            public bool IsDefault { get; }

            public string Description { get; }
        }

        private enum RegisterMode
        {
            ReadWrite,
            ReadClear,
            ReadOnly
        }

        private enum PropertyType
        {
            Enum,
            FlagsEnum,
            Numeric
        }

        private class RegisterProperty
        {
            public RegisterProperty(
                PropertyType propertyType,
                RegisterMode registerMode,
                string propertyName,
                string paramName,
                string type,
                string defaultValue,
                string description,
                Action<CodeWriter, string> appendPropertyAssigmentValidation,
                Action<CodeWriter, string[]> appendPropertyAssigmentFromBytes,
                Func<string[]> getByteIndexAsByteStrings,
                int byteIndex)
            {
                PropertyType = propertyType;
                RegisterMode = registerMode;
                PropertyName = propertyName;
                ParamName = paramName;
                Type = type;
                DefaultValue = defaultValue;
                Description = description;
                AppendPropertyAssigmentValidation = appendPropertyAssigmentValidation;
                AppendPropertyAssigmentFromBytes = appendPropertyAssigmentFromBytes;
                GetByteIndexAsByteStrings = getByteIndexAsByteStrings;
                ByteIndex = byteIndex;
            }

            public PropertyType PropertyType { get; }

            public RegisterMode RegisterMode { get; }

            public string PropertyName { get; }

            public string ParamName { get; }

            public string Type { get; }

            public string DefaultValue { get; }

            public string Description { get; }

            public Action<CodeWriter, string> AppendPropertyAssigmentValidation { get; }

            public Action<CodeWriter, string[]> AppendPropertyAssigmentFromBytes { get; }

            public Func<string[]> GetByteIndexAsByteStrings { get; }

            public int ByteIndex { get; }
        }

        public RegisterCodeGenerator(XDocument registersXml, bool verboseComments)
        {
            _registersXml = registersXml;
            _verboseComments = verboseComments;
        }

        public string Generate()
        {
            var code = new CodeWriter(this);
            code.AppendCommentLine("=============================================================");
            code.AppendCommentLine("This code file is autogenerated. Do not modify it manually!");
            code.AppendCommentLine("=============================================================");
            code.AppendLine();


            XElement registersNode = _registersXml.Element("Registers");
            var ns = registersNode?.Attribute("namespace")?.Value ?? "missing.namespace";

            code.AppendLine("using System;");
            code.AppendLine();
            code.AppendLine("namespace " + ns);
            code.AppendLine("{");
            code.Indent++;

            XElement[] registerGroupElements = registersNode?.Elements("RegisterGroup").ToArray() ?? new XElement[0];

            Iterate(registerGroupElements, (registerGroupElement, isLastGroup) =>
            {
                string prefix = registerGroupElement.Attribute("prefix")?.Value ?? string.Empty;

                XElement[] registerElements = registerGroupElement.Elements("Register")
                    .OrderBy(GetRegisterAddress)
                    .ToArray();

                GenerateRegisterAddressEnum(code, prefix, registerElements);
                GenerateAbstractRegister(code, prefix);

                Iterate(registerElements, (registerElement, isLastRegister) =>
                {
                    GenerateRegister(code, prefix, registerElement);

                    if (!isLastGroup || !isLastRegister)
                    {
                        code.AppendLine();
                    }
                });
            });

            code.Indent--;
            code.AppendLine("}");

            return code.GetAllCode();
        }

        string IReferenceResolver.ResolveReference(string reference)
        {
            string[] parts = reference.Split('.');

            if (parts.Length == 1)
            {
                return reference;
            }

            if (parts.Length >= 2)
            {
                XElement registerGroupElement = FindElement(_registersXml.Element("Registers"), "prefix", parts[0]);
                XElement registerElement = FindElement(registerGroupElement, "name", parts[1]);

                string registerName = GetRegisterName(
                    registerGroupElement?.Attribute("prefix")?.Value,
                    registerElement?.Attribute("name")?.Value);

                if (parts.Length == 2)
                {
                    return registerName;
                }

                XElement propertyElement = FindElement(registerElement, "name", parts[2]);

                return registerName + "." + propertyElement?.Attribute("name")?.Value;
            }

            return "(BAD REFERENCE!) " + reference;
        }

        private static XElement FindElement(XElement parent, string attributeName, string name)
        {
            XElement[] elements = parent?.Elements().ToArray() ?? new XElement[0];

            foreach (XElement element in elements)
            {
                string value = element.Attribute(attributeName)?.Value ?? string.Empty;
                if (value == name)
                {
                    return element;
                }
            }

            return null;
        }

        private static byte GetRegisterAddress(XElement registerElement)
        {
            string address = registerElement.Attribute("address")?.Value;
            return (byte)ConvertToInteger(address);
        }

        private static uint GetNumericalValue(XElement element)
        {
            string value = element.Attribute("value")?.Value;
            return ConvertToInteger(value);
        }

        private static uint ConvertToInteger(string value)
        {
            if (string.IsNullOrEmpty(value))
            {
                throw new ArgumentException("Missing numerical value");
            }

            if (value.StartsWith("0x"))
            {
                return uint.Parse(value.Substring(2), NumberStyles.HexNumber);
            }

            return uint.Parse(value);
        }

        private static string GetName(XElement element)
        {
            return GetTrimmedValue(element, "name");
        }

        private static string GetDescription(XElement element)
        {
            return GetTrimmedValue(element, "description");
        }

        private static string GetTrimmedValue(XElement element, string name)
        {
            return element.Attribute(name)?.Value.Trim();
        }

        private static void GenerateDescription(CodeWriter code, string description)
        {
            if (!string.IsNullOrEmpty(description))
            {
                code.AppendDocumentationCommentLine("<summary>");
                string[] lines = Regex.Split(description, "\r\n");
                foreach (string line in lines)
                {
                    code.AppendDocumentationCommentLine(line.Trim());
                }
                code.AppendDocumentationCommentLine("</summary>");
            }
        }

        private static void GenerateRegisterAddressEnum(CodeWriter code, string prefix, XElement[] registerElements)
        {
            string registerAddressEnumName = GetRegisterAddressEnumName(prefix);

            code.AppendLine($"public enum {registerAddressEnumName}");
            code.AppendLine("{");
            code.Indent++; // Enum

            Iterate(registerElements, (registerElement, isLastRegister) =>
            {
                GenerateDescription(code, GetDescription(registerElement));

                string name = GetName(registerElement);
                byte address = GetRegisterAddress(registerElement);

                code.AppendLine($"{name} = {ToHex(address, 2)}{(isLastRegister ? string.Empty : ",")}");

                if (!isLastRegister)
                {
                    code.AppendLine();
                }
            });

            code.Indent--; // Enum
            code.AppendLine("}");
            code.AppendLine();
        }

        private static string GetRegisterName(string prefix, string name)
        {
            return prefix + "Register" + name;
        }

        private static string GetRegisterAddressEnumName(string prefix)
        {
            return prefix + "RegisterAddress";
        }

        private static int GetRegisterLength(XElement registerElement)
        {
            string length = registerElement.Attribute("length")?.Value;
            if (string.IsNullOrEmpty(length))
            {
                return 1;
            }

            return int.Parse(length);
        }

        private static RegisterMode GetRegisterMode(XElement registerElement)
        {
            string mode = registerElement.Attribute("mode")?.Value;
            if (string.IsNullOrEmpty(mode))
            {
                return RegisterMode.ReadWrite;
            }

            return (RegisterMode)Enum.Parse(typeof(RegisterMode), mode);
        }

        private static BitsRange GetBitsRange(XElement element)
        {
            var bits = element.Attribute("bits")?.Value;
            if (string.IsNullOrEmpty(bits))
            {
                return null;
            }

            try
            {
                int[] values = bits.Split('-').Select(x => x.Trim()).Select(int.Parse).ToArray();
                if (values.Length == 1)
                {
                    return new BitsRange(values[0], values[0]);
                }

                if (values.Length == 2)
                {
                    return new BitsRange(values[0], values[1]);
                }

                throw new ArgumentException("Bad range");
            }
            catch
            {
                throw new ArgumentException($"Bad bits-attribute: \"{bits}\"");
            }
        }

        private static void GenerateAbstractRegister(CodeWriter code, string prefix)
        {
            string className = GetRegisterName(prefix, string.Empty);
            string registerAddressEnumName = GetRegisterAddressEnumName(prefix);

            code.AppendLine($"public abstract class {className} : Register");
            code.AppendLine("{");
            code.Indent++; // Class
            code.AppendLine($"internal {className}({registerAddressEnumName} address, byte length)");
            code.Indent++; // base
            code.AppendLine(": base((byte)address, length)");
            code.Indent--; // base
            code.AppendLine("{");
            code.AppendLine("}");
            code.Indent--; // Class
            code.AppendLine("}");
            code.AppendLine();
        }

        private static void Iterate<T>(IReadOnlyList<T> items, Action<T, bool> iterator)
        {
            for (int i = 0; i < items.Count; i++)
            {
                iterator(items[i], i == items.Count - 1);
            }
        }

        private static string GetLocalName(string publicName)
        {
            return publicName[0].ToString().ToLower() + publicName.Substring(1);
        }

        private void GenerateRegister(CodeWriter code, string prefix, XElement registerElement)
        {
            string name = GetName(registerElement);
            string className = GetRegisterName(prefix, name);
            string registerAddressEnumName = GetRegisterAddressEnumName(prefix);
            int registerLength = GetRegisterLength(registerElement);
            RegisterMode registerMode = GetRegisterMode(registerElement);

            string baseClassName = GetRegisterName(prefix, string.Empty);

            var properties = new List<RegisterProperty>();

            // ------------------------------
            // Class declaration
            GenerateDescription(code, GetDescription(registerElement));
            code.AppendLine($"[Register((byte){registerAddressEnumName}.{name}, {registerLength})]");
            code.AppendLine($"public class {className} : {baseClassName}");
            code.AppendLine("{");
            code.Indent++; // Class

            // ------------------------------
            // Enum declarations
            foreach (XElement element in registerElement.Elements())
            {
                switch (element.Name.LocalName)
                {
                    case "Enum":
                        GenerateEnum(code, registerMode, registerLength, properties, element, false);
                        break;

                    case "Flags":
                        GenerateEnum(code, registerMode, registerLength, properties, element, true);
                        break;

                    case "Number":
                        GenerateNumber(code, registerMode, registerLength, properties, element);
                        break;
                }
            }

            bool oneByteRegister = (properties.Count == 1) && (properties[0].Type == "byte");
            const string oneByteRegisterParamName = "value";



            // ------------------------------
            // Constructor taking bytes as parameters
            var byteParameterNames = new List<string>();
            if (registerLength == 1)
            {
                byteParameterNames.Add(oneByteRegister ? oneByteRegisterParamName : "registerValue");
            }
            else
            {
                for (int i = 0; i < registerLength; i++)
                {
                    byteParameterNames.Add($"registerValue{i + 1}");
                }
            }


            Action<CodeWriter> appendConstructorBody1 = codeWriter =>
            {
                foreach (RegisterProperty property in properties)
                {
                    property.AppendPropertyAssigmentValidation(codeWriter, oneByteRegister ? oneByteRegisterParamName : property.ParamName);
                }

                AppendVerboseComment(codeWriter, "Assigning properties.");
                foreach (RegisterProperty property in properties)
                {
                    codeWriter.AppendLine($"{property.PropertyName} = {(oneByteRegister ? oneByteRegisterParamName : property.ParamName)};");
                }
            };

            Action<CodeWriter> appendConstructorBody2 = codeWriter =>
            {
                foreach (RegisterProperty property in properties)
                {
                    property.AppendPropertyAssigmentFromBytes(codeWriter, byteParameterNames.ToArray());
                }
            };

            bool oneByteRegisterOneConstructorBody = false;

            if (oneByteRegister)
            {
                // Special case -- both constructor take just one byte as input.

                var cw1 = new CodeWriter(this, true);
                var cw2 = new CodeWriter(this, true);
                appendConstructorBody1(cw1);
                appendConstructorBody2(cw2);

                oneByteRegisterOneConstructorBody = cw1.GetAllCode() == cw2.GetAllCode();

                if (oneByteRegisterOneConstructorBody)
                {
                    // Both one-byte constructors have the exact same body.
                    // No need to separate them by type of call.

                    // ------------------------------
                    // Constructor taking the enums as parameters
                    code.AppendLine($"public {className}(byte {oneByteRegisterParamName})");
                    code.Indent++; // Constructor base
                    code.AppendLine($": base({registerAddressEnumName}.{name}, {registerLength})");
                    code.Indent--; // Constructor base
                    code.AppendLine("{");
                    code.Indent++; // Constructor body
                    appendConstructorBody1(code);
                    code.Indent--; // Constructor body
                    code.AppendLine("}");
                }
                else
                {
                    // ------------------------------
                    // Constructor taking the enums as parameters
                    code.AppendLine($"public {className}(byte {oneByteRegisterParamName}, bool isRegisterValue)");
                    code.Indent++; // Constructor base
                    code.AppendLine($": base({registerAddressEnumName}.{name}, {registerLength})");
                    code.Indent--; // Constructor base
                    code.AppendLine("{");
                    code.Indent++; // Constructor body

                    code.AppendLine("if (isRegisterValue)");
                    code.AppendLine("{");
                    code.Indent++;
                    appendConstructorBody2(code);
                    code.Indent--;
                    code.AppendLine("}");
                    code.AppendLine("else");
                    code.AppendLine("{");
                    code.Indent++;
                    appendConstructorBody1(code);
                    code.Indent--;
                    code.AppendLine("}");

                    code.Indent--; // Constructor body
                    code.AppendLine("}");
                }
            }
            else
            {
                // ------------------------------
                // Constructor taking the enums as parameters
                code.AppendLine($"public {className}(");
                code.Indent++; // Constructor parameters
                Iterate(properties, (prop, isLast) =>
                {
                    code.AppendLine($"{prop.Type} {prop.ParamName}{(isLast ? ")" : ",")}");
                });
                code.AppendLine($": base({registerAddressEnumName}.{name}, {registerLength})");
                code.Indent--; // Constructor parameters
                code.AppendLine("{");
                code.Indent++; // Constructor body

                appendConstructorBody1(code);
                //foreach (RegisterProperty property in properties)
                //{
                //    property.AppendPropertyAssigmentValidation();
                //}

                //AppendVerboseComment(code, "Assigning properties.");
                //foreach (RegisterProperty property in properties)
                //{
                //    code.AppendLine($"{property.PropertyName} = {property.ParamName};");
                //}

                code.Indent--; // Constructor body
                code.AppendLine("}");


                code.AppendLine();
                code.AppendLine($"public {className}({string.Join(", ", byteParameterNames.Select(x => "byte " + x))})");
                code.Indent++; // Constructor base call
                code.AppendLine($": base({registerAddressEnumName}.{name}, {registerLength})");
                code.Indent--; // Constructor base call
                code.AppendLine("{");
                code.Indent++; // Constructor body

                appendConstructorBody2(code);
                //foreach (RegisterProperty property in properties)
                //{
                //    property.AppendPropertyAssigmentFromBytes(byteParameterNames.ToArray());
                //}

                code.Indent--; // Constructor body
                code.AppendLine("}");
            }



            // ------------------------------
            // Constructor from byte-array
            List<string> createFromBytesArguments = byteParameterNames.Select((x, i) => $"registerValues[{i}]").ToList();
            if (oneByteRegister && !oneByteRegisterOneConstructorBody)
            {
                createFromBytesArguments.Add("true");
            }

            code.AppendLine();
            code.AppendLine($"internal {className}(byte[] registerValues)");
            code.Indent++; // Constrctor this-call
            code.AppendLine($": this({string.Join(", ", createFromBytesArguments)})");
            code.Indent--; // Constrctor this-call
            code.AppendLine("{");
            code.AppendLine("}");



            if (registerMode == RegisterMode.ReadWrite)
            {
                code.AppendLine();

                // ------------------------------
                // Default register value
                GenerateDescription(code, "Reset values.");

                List<string> defaultArguments = properties.Select(prop => prop.DefaultValue).ToList();
                if (oneByteRegister && !oneByteRegisterOneConstructorBody)
                {
                    defaultArguments.Add("false");
                }

                if (defaultArguments.Count == 1)
                {
                    code.AppendLine($"public static readonly {className} Default = new {className}({defaultArguments[0]});");
                }
                else
                {
                    code.AppendLine($"public static readonly {className} Default = new {className}(");
                    code.Indent++; // Constructor arguments
                    Iterate(defaultArguments, (defaultArgument, isLast) =>
                    {
                        code.AppendLine($"{defaultArgument}{(isLast ? ");" : ",")}");
                    });
                    code.Indent--; // Constructor arguments
                }
            }


            // ------------------------------
            // Property declarations
            foreach (RegisterProperty prop in properties)
            {
                code.AppendLine();
                GenerateDescription(code, prop.Description);
                code.AppendLine($"public {prop.Type} {prop.PropertyName} {{ get; }}");
            }


            // ------------------------------
            // Abstract method: GetAsBytes
            code.AppendLine();
            code.AppendLine("internal override byte[] GetAsBytes()");
            code.AppendLine("{");
            code.Indent++; // Method body

            string[][] getAsBytesMap = properties.Select(p => p.GetByteIndexAsByteStrings()).ToArray();

            var getAsBytesList = new List<string>();
            for (int i = 0; i < registerLength; i++)
            {
                //string[] getAsBytes = getAsBytesMap[i];
                string[] getAsBytes = getAsBytesMap.Select(x => x[i]).Where(x => !string.IsNullOrEmpty(x)).ToArray();

                //string[] getAsBytes = properties.Select(p => p.GetByteIndexAsByteString(i)).Where(x => !string.IsNullOrEmpty(x)).ToArray();
                string getByte;
                if (getAsBytes.Length == 0)
                {
                    getByte = "(byte)0";
                }
                else if (getAsBytes.Length == 1)
                {
                    getByte = getAsBytes[0];
                }
                else
                {
                    getByte = $"(byte)({string.Join(" | ", getAsBytes)})";
                }

                getAsBytesList.Add(getByte);
            }

            if (getAsBytesList.Count == 1)
            {
                code.AppendLine($"return new[] {{ {getAsBytesList[0]} }};");
            }
            else
            {
                code.AppendLine("return new[]");
                code.AppendLine("{");
                code.Indent++; // Array content
                Iterate(getAsBytesList, (codeLine, isLast) => code.AppendLine(codeLine + (isLast ? string.Empty : ",")));
                code.Indent--; // Array content
                code.AppendLine("};");
            }

            //code.AppendLine("throw new NotImplementedException();");
            code.Indent--; // Method body
            code.AppendLine("}");

            // ------------------------------
            code.Indent--; // Class
            code.AppendLine("}");
        }

        private void AppendVerboseComment(CodeWriter code, string comment)
        {
            if (_verboseComments)
            {
                code.AppendCommentLine(comment);
            }
        }

        private void GenerateEnum(
            CodeWriter code,
            RegisterMode registerMode,
            int registerLength,
            List<RegisterProperty> properties,
            XElement element,
            bool isFlags)
        {
            string name = GetName(element);
            string enumName = name + "Enum";

            int byteIndex;
            var bitsRange = GetBitsRange(element, registerLength, null, out byteIndex);

            EnumValue[] enumValues = element.Elements("Value")
                .Select(GetEnumValue)
                .OrderBy(x => x.Value)
                .ToArray();

            switch (registerMode)
            {
                case RegisterMode.ReadWrite:
                    if (enumValues.Count(x => x.IsDefault) != 1)
                    {
                        throw new Exception("Exactly one default enum value expected: " + name);
                    }
                    break;

                case RegisterMode.ReadClear:
                case RegisterMode.ReadOnly:
                    if (enumValues.Count(x => x.IsDefault) != 0)
                    {
                        throw new Exception("No default enum value expected: " + name);
                    }
                    break;
            }

            GenerateDescription(code, GetDescription(element));

            //code.AppendLine(bitsRange.FromBits == bitsRange.ToBits
            //    ? $"[BitMask({bitsRange.FromBits})]"
            //    : $"[BitMask({bitsRange.FromBits}, {bitsRange.ToBits})]");

            string integerType = GetIntegerType(bitsRange);

            if (isFlags)
            {
                code.AppendLine("[Flags]");
            }

            code.AppendLine($"public enum {enumName} : {integerType}");
            code.AppendLine("{");
            code.Indent++; // Enum values

            bool isFirst = true;
            Iterate(enumValues, (enumValue, isLast) =>
            {
                if (isFirst)
                {
                    isFirst = false;
                }
                else if (!string.IsNullOrEmpty(enumValue.Description))
                {
                    code.AppendLine();
                }

                byte value = enumValue.Value;
                //byte value = (byte)(enumValue.Value << bitsRange.FromBits);

                GenerateDescription(code, enumValue.Description);
                code.AppendLine($"{enumValue.Name} = {ToHex(value, 2)}{(isLast ? string.Empty : ",")}");
            });

            code.Indent--; // Enum values
            code.AppendLine("}");
            code.AppendLine();

            string defaultValue;
            if (registerMode == RegisterMode.ReadWrite)
            {
                defaultValue = enumName + "." + enumValues.Single(x => x.IsDefault).Name;
            }
            else
            {
                defaultValue = null;
            }

            Action<CodeWriter, string[]> appendPropertyAssigmentFromBytes = (codeWriter, byteParameterNames) =>
            {
                var composedValue = GetComposedValue(bitsRange, registerLength, byteIndex, byteParameterNames);
                codeWriter.AppendLine($"{name} = ({enumName})Enum.ToObject(typeof({enumName}), {composedValue});");
            };

            Func<string[]> getByteIndexAsByteStrings = () =>
                GetDecomposedValues(name, bitsRange, registerLength, byteIndex, false);

            properties.Add(new RegisterProperty(
                PropertyType.Enum,
                registerMode,
                name,
                GetLocalName(name),
                enumName,
                defaultValue,
                GetDescription(element),
                (codeWriter, paramName) => { },
                appendPropertyAssigmentFromBytes,
                getByteIndexAsByteStrings,
                byteIndex));
        }

        private void GenerateNumber(
            CodeWriter code,
            RegisterMode registerMode,
            int registerLength,
            List<RegisterProperty> properties,
            XElement element)
        {
            string name = GetName(element) ?? "Value";
            string paramName = GetLocalName(name);

            int byteIndex;
            BitsRange bitsRange = GetBitsRange(element, registerLength, null, out byteIndex);

            uint defaultValue;
            if (registerMode == RegisterMode.ReadWrite)
            {
                defaultValue = ConvertToInteger(element.Attribute("default")?.Value) << bitsRange.FromBits;
            }
            else
            {
                defaultValue = 0;
            }

            string integerType = GetIntegerType(bitsRange);

            Action<CodeWriter, string> appendPropertyAssigmentValidation = (codeWriter, actualParamName) =>
            {
                uint integerTypeMaxValue = GetIntegerTypeMaxValue(bitsRange);
                if (integerTypeMaxValue != bitsRange.MaxValue)
                {
                    AppendVerboseComment(codeWriter, "Validating the numerical range.");
                    codeWriter.AppendLine($"if ({actualParamName} > {ToHex(bitsRange.MaxValue, bitsRange.NibbleCount)})");
                    codeWriter.AppendLine("{");
                    codeWriter.Indent++;
                    codeWriter.AppendLine($"throw new ArgumentException($\"{{nameof({actualParamName})}} must be in the range of [{ToHex(0, bitsRange.NibbleCount)} - {ToHex(bitsRange.MaxValue, bitsRange.NibbleCount)}].\");");
                    codeWriter.Indent--;
                    codeWriter.AppendLine("}");
                    codeWriter.AppendLine();
                }
            };

            Action<CodeWriter, string[]> appendPropertyAssigmentFromBytes = (codeWriter, byteParameterNames) =>
            {
                AppendVerboseComment(codeWriter, "Assigning the composed numerical value.");
                string composedValue = GetComposedValue(bitsRange, registerLength, byteIndex, byteParameterNames);
                codeWriter.AppendLine($"{name} = {composedValue};");
            };

            Func<string[]> getByteIndexAsByteStrings = () =>
                GetDecomposedValues(name, bitsRange, registerLength, byteIndex, true);

            properties.Add(new RegisterProperty(
                PropertyType.Numeric,
                registerMode,
                name,
                paramName,
                integerType,
                ToHex(defaultValue, bitsRange.NibbleCount),
                GetDescription(element),
                appendPropertyAssigmentValidation,
                appendPropertyAssigmentFromBytes,
                getByteIndexAsByteStrings,
                byteIndex));
        }

        private static string GetIntegerType(BitsRange bitsRange)
        {
            string type;
            switch (bitsRange.ByteCount)
            {
                case 1:
                    type = "byte";
                    break;

                case 2:
                    type = "ushort";
                    break;

                case 3:
                case 4:
                    type = "uint";
                    break;

                default:
                    throw new Exception($"Unsupported integer size: {bitsRange.ByteCount} bytes.");
            }
            return type;
        }

        private static uint GetIntegerTypeMaxValue(BitsRange bitsRange)
        {
            switch (bitsRange.ByteCount)
            {
                case 1:
                    return 0xFF;

                case 2:
                    return 0xFFFF;

                case 3:
                case 4:
                    return 0xFFFFFFFF;

                default:
                    throw new Exception($"Unsupported integer size: {bitsRange.ByteCount} bytes.");
            }
        }

        private static string GetComposedValue(
            BitsRange bitsRange,
            int registerLength,
            int byteIndex,
            string[] byteParameterNames)
        {
            byte[] byteMasks = bitsRange.GetByteMasks(registerLength, byteIndex);

            bool anyMask = false;
            var byteMaskList = new List<string>();
            for (int i = 0; i < byteMasks.Length; i++)
            {
                if (byteMasks[i] > 0)
                {
                    bool needsMask = byteMasks[i] != 0xFF;

                    string byteMask = !needsMask
                        ? byteParameterNames[i]
                        : $"({byteParameterNames[i]} & {ToHex(byteMasks[i], 2)})";

                    int shift = bitsRange.FromBits - (byteIndex - i) * 8;

                    byteMask = ShiftValue(byteMask, shift);

                    byteMaskList.Add(byteMask);

                    if (needsMask)
                    {
                        anyMask = true;
                    }
                }
            }

            string composedValue;
            bool needsCasting;

            if ((byteMaskList.Count == 1) && !anyMask)
            {
                needsCasting = false;
                composedValue = byteMaskList[0];
            }
            else
            {
                needsCasting = true;
                composedValue = ((byteMaskList.Count == 1) && anyMask)
                    ? $"{string.Join(" | ", byteMaskList)}"
                    : $"({string.Join(" | ", byteMaskList)})";
            }

            if (needsCasting)
            {
                composedValue = $"({GetIntegerType(bitsRange)})" + composedValue;
            }

            return composedValue;
        }

        private static string[] GetDecomposedValues(
            string name,
            BitsRange bitsRange,
            int registerLength,
            int byteIndex,
            bool isNumeric)
        {
            byte[] byteMasks = bitsRange.GetByteMasks(registerLength, byteIndex);

            var getAsBytesValues = new string[registerLength];

            if (!isNumeric)
            {
                name = $"({GetIntegerType(bitsRange)}){name}";
            }

            for (int i = 0; i < byteMasks.Length; i++)
            {
                if (byteMasks[i] > 0)
                {
                    bool needsMask = byteMasks[i] != 0xFF;

                    int shift = (byteIndex - i) * 8 - bitsRange.FromBits;

                    string propertyMask = ShiftValue(name, shift);

                    if (needsMask)
                    {
                        propertyMask = $"(byte)({propertyMask} & {ToHex(byteMasks[i], 2)})";
                    }
                    else if (bitsRange.ByteCount > 1)
                    {
                        propertyMask = "(byte)" + propertyMask;
                    }

                    getAsBytesValues[i] = propertyMask;
                }
            }

            return getAsBytesValues;
        }

        private static string ShiftValue(string value, int shift)
        {
            if (shift == 0)
            {
                return value;
            }

            return shift < 0
                ? $"({value} << {-shift})"
                : $"({value} >> {shift})";
        }

        private static BitsRange GetBitsRange(XElement element, int registerLength, BitsRange defaultBitsRange, out int byteIndex)
        {
            BitsRange bitsRange = GetBitsRange(element) ?? defaultBitsRange;

            byteIndex = registerLength - 1;
            while (bitsRange.FromBits > 7)
            {
                byteIndex--;
                bitsRange = new BitsRange(bitsRange.FromBits - 8, bitsRange.ToBits - 8);
            }

            return bitsRange;
        }

        private static string ToHex(uint value, int nibbleCount)
        {
            return "0x" + value.ToString("X" + nibbleCount);
        }

        private static EnumValue GetEnumValue(XElement valueElement)
        {
            string name = GetName(valueElement);
            string description = GetDescription(valueElement);
            bool isDefault = valueElement.Attribute("isDefault")?.Value.Equals("true", StringComparison.OrdinalIgnoreCase) ?? false;
            byte value = (byte)GetNumericalValue(valueElement);
            return new EnumValue(name, value, isDefault, description);
        }
    }
}