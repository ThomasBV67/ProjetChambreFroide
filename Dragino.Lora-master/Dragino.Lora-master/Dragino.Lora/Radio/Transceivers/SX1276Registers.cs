// =============================================================
// This code file is autogenerated. Do not modify it manually!
// =============================================================

using System;

namespace Dragino.Radio.Transceivers
{
    public enum CommonRegisterAddress
    {
        /// <summary>
        /// FIFO read/write access.
        /// </summary>
        Fifo = 0x00,

        /// <summary>
        /// Operating mode & LoRa / FSK selection.
        /// </summary>
        OpMode = 0x01,

        /// <summary>
        /// RF Carrier Frequency, Least Significant Bits (of 24 bits).
        /// </summary>
        Frf = 0x06,

        /// <summary>
        /// PA selection and Output Power control.
        /// </summary>
        PaConfig = 0x09,

        /// <summary>
        /// Control of PA ramp time, low phase noise PLL.
        /// </summary>
        PaRamp = 0x0A,

        /// <summary>
        /// Over Current Protection control.
        /// </summary>
        Ocp = 0x0B,

        /// <summary>
        /// LNA settings.
        /// </summary>
        Lna = 0x0C,

        /// <summary>
        /// Mapping of pins DIO0 to DIO3.
        /// </summary>
        DioMapping1 = 0x40,

        /// <summary>
        /// Mapping of pins DIO4 and DIO5, ClkOut frequency.
        /// </summary>
        DioMapping2 = 0x41,

        /// <summary>
        /// Semtech ID relating the silicon revision.
        /// </summary>
        Version = 0x42,

        /// <summary>
        /// TCXO or XTAL input setting.
        /// </summary>
        Tcxo = 0x4B,

        /// <summary>
        /// Higher power settings of the PA.
        /// </summary>
        PaDac = 0x4D,

        /// <summary>
        /// Stored temperature during the former IQ Calibration.
        /// </summary>
        FormerTemp = 0x5B,

        /// <summary>
        /// Adjustment of the AGC thresholds.
        /// </summary>
        AgcRef = 0x61,

        /// <summary>
        /// Adjustment of the AGC thresholds.
        /// </summary>
        AgcThresh1 = 0x62,

        /// <summary>
        /// Adjustment of the AGC thresholds.
        /// </summary>
        AgcThresh2 = 0x63,

        /// <summary>
        /// Adjustment of the AGC thresholds.
        /// </summary>
        AgcThresh3 = 0x64,

        /// <summary>
        /// Control of the PLL bandwidth.
        /// </summary>
        Pll = 0x70
    }

    public abstract class CommonRegister : Register
    {
        internal CommonRegister(CommonRegisterAddress address, byte length)
            : base((byte)address, length)
        {
        }
    }

    /// <summary>
    /// FIFO read/write access.
    /// </summary>
    [Register((byte)CommonRegisterAddress.Fifo, 1)]
    public class CommonRegisterFifo : CommonRegister
    {
        public CommonRegisterFifo(byte value)
            : base(CommonRegisterAddress.Fifo, 1)
        {
            // Assigning properties.
            Value = value;
        }

        internal CommonRegisterFifo(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterFifo Default = new CommonRegisterFifo(0x00);

        public byte Value { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { Value };
        }
    }

    /// <summary>
    /// Operating mode & LoRa / FSK selection.
    /// </summary>
    [Register((byte)CommonRegisterAddress.OpMode, 1)]
    public class CommonRegisterOpMode : CommonRegister
    {
        /// <summary>
        /// This bit can be modified only in Sleep mode. A write operation on other device modes is ignored.
        /// </summary>
        public enum LongRangeModeEnum : byte
        {
            /// <summary>
            /// FSK/OOK Mode.
            /// </summary>
            FskOokMode = 0x00,

            /// <summary>
            /// LoRa Mode.
            /// </summary>
            LoRaMode = 0x01
        }

        /// <summary>
        /// This bit operates when device is in Lora mode; if set it allows access to FSK registers page located in address space (0x0D:0x3F) while in LoRa mode.
        /// </summary>
        public enum AccessSharedRegEnum : byte
        {
            /// <summary>
            /// Access LoRa registers page 0x0D: 0x3F.
            /// </summary>
            AccessLoRaRegisterPage = 0x00,

            /// <summary>
            /// Access FSK registers page (in mode LoRa) 0x0D: 0x3F.
            /// </summary>
            AccessFskRegisterPage = 0x01
        }

        /// <summary>
        /// Access Low Frequency Mode registers.
        /// </summary>
        public enum LowFrequencyModeOnEnum : byte
        {
            /// <summary>
            /// High Frequency Mode (access to HF test registers).
            /// </summary>
            HighFrequencyMode = 0x00,

            /// <summary>
            /// Low Frequency Mode (access to LF test registers).
            /// </summary>
            LowFrequencyMode = 0x01
        }

        /// <summary>
        /// Device modes.
        /// </summary>
        public enum DeviceModeEnum : byte
        {
            /// <summary>
            /// SLEEP.
            /// </summary>
            Sleep = 0x00,

            /// <summary>
            /// STDBY.
            /// </summary>
            StandBy = 0x01,

            /// <summary>
            /// Frequency synthesis TX (FSTX).
            /// </summary>
            FrequencySynthesisTx = 0x02,

            /// <summary>
            /// Transmit (TX).
            /// </summary>
            Transmit = 0x03,

            /// <summary>
            /// Frequency synthesis RX (FSRX).
            /// </summary>
            FrequencySynthesisRx = 0x04,

            /// <summary>
            /// Receive continuous (RXCONTINUOUS)
            /// </summary>
            ReceiveContinuous = 0x05,

            /// <summary>
            /// Receive single (RXSINGLE).
            /// </summary>
            ReceiveSingle = 0x06,

            /// <summary>
            /// Channel activity detection (CAD).
            /// </summary>
            ChannelActivityDetection = 0x07
        }

        public CommonRegisterOpMode(
            LongRangeModeEnum longRangeMode,
            AccessSharedRegEnum accessSharedReg,
            LowFrequencyModeOnEnum lowFrequencyModeOn,
            DeviceModeEnum deviceMode)
            : base(CommonRegisterAddress.OpMode, 1)
        {
            // Assigning properties.
            LongRangeMode = longRangeMode;
            AccessSharedReg = accessSharedReg;
            LowFrequencyModeOn = lowFrequencyModeOn;
            DeviceMode = deviceMode;
        }

        public CommonRegisterOpMode(byte registerValue)
            : base(CommonRegisterAddress.OpMode, 1)
        {
            LongRangeMode = (LongRangeModeEnum)Enum.ToObject(typeof(LongRangeModeEnum), (byte)((registerValue & 0x80) >> 7));
            AccessSharedReg = (AccessSharedRegEnum)Enum.ToObject(typeof(AccessSharedRegEnum), (byte)((registerValue & 0x40) >> 6));
            LowFrequencyModeOn = (LowFrequencyModeOnEnum)Enum.ToObject(typeof(LowFrequencyModeOnEnum), (byte)((registerValue & 0x08) >> 3));
            DeviceMode = (DeviceModeEnum)Enum.ToObject(typeof(DeviceModeEnum), (byte)(registerValue & 0x07));
        }

        internal CommonRegisterOpMode(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterOpMode Default = new CommonRegisterOpMode(
            LongRangeModeEnum.FskOokMode,
            AccessSharedRegEnum.AccessFskRegisterPage,
            LowFrequencyModeOnEnum.HighFrequencyMode,
            DeviceModeEnum.StandBy);

        /// <summary>
        /// This bit can be modified only in Sleep mode. A write operation on other device modes is ignored.
        /// </summary>
        public LongRangeModeEnum LongRangeMode { get; }

        /// <summary>
        /// This bit operates when device is in Lora mode; if set it allows access to FSK registers page located in address space (0x0D:0x3F) while in LoRa mode.
        /// </summary>
        public AccessSharedRegEnum AccessSharedReg { get; }

        /// <summary>
        /// Access Low Frequency Mode registers.
        /// </summary>
        public LowFrequencyModeOnEnum LowFrequencyModeOn { get; }

        /// <summary>
        /// Device modes.
        /// </summary>
        public DeviceModeEnum DeviceMode { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)LongRangeMode << 7) & 0x80) | (byte)(((byte)AccessSharedReg << 6) & 0x40) | (byte)(((byte)LowFrequencyModeOn << 3) & 0x08) | (byte)((byte)DeviceMode & 0x07)) };
        }
    }

    /// <summary>
    /// RF Carrier Frequency, Least Significant Bits (of 24 bits).
    /// </summary>
    [Register((byte)CommonRegisterAddress.Frf, 3)]
    public class CommonRegisterFrf : CommonRegister
    {
        public CommonRegisterFrf(
            uint value)
            : base(CommonRegisterAddress.Frf, 3)
        {
            // Validating the numerical range.
            if (value > 0xFFFFFF)
            {
                throw new ArgumentException($"{nameof(value)} must be in the range of [0x000000 - 0xFFFFFF].");
            }

            // Assigning properties.
            Value = value;
        }

        public CommonRegisterFrf(byte registerValue1, byte registerValue2, byte registerValue3)
            : base(CommonRegisterAddress.Frf, 3)
        {
            // Assigning the composed numerical value.
            Value = (uint)((registerValue1 << 16) | (registerValue2 << 8) | registerValue3);
        }

        internal CommonRegisterFrf(byte[] registerValues)
            : this(registerValues[0], registerValues[1], registerValues[2])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterFrf Default = new CommonRegisterFrf(0x6C8000);

        public uint Value { get; }

        internal override byte[] GetAsBytes()
        {
            return new[]
            {
                (byte)(Value >> 16),
                (byte)(Value >> 8),
                (byte)Value
            };
        }
    }

    /// <summary>
    /// PA selection and Output Power control.
    /// </summary>
    [Register((byte)CommonRegisterAddress.PaConfig, 1)]
    public class CommonRegisterPaConfig : CommonRegister
    {
        /// <summary>
        /// Selects PA output pin
        /// </summary>
        public enum PaSelectEnum : byte
        {
            /// <summary>
            /// Output power is limited to +14 dBm.
            /// </summary>
            RfoPin = 0x00,

            /// <summary>
            /// Output power is limited to +20 dBm
            /// </summary>
            PaBoostPin = 0x01
        }

        /// <summary>
        /// Select max output power (10.8 - 15.0 dBm).
        /// </summary>
        public enum MaxPowerEnum : byte
        {
            /// <summary>
            /// Pmax = 10.8 dBm.
            /// </summary>
            PMax10_8dBm = 0x00,

            /// <summary>
            /// Pmax = 11.4 dBm.
            /// </summary>
            PMax11_4dBm = 0x01,

            /// <summary>
            /// Pmax = 12.0 dBm.
            /// </summary>
            PMax12_0dBm = 0x02,

            /// <summary>
            /// Pmax = 12.6 dBm.
            /// </summary>
            PMax12_6dBm = 0x03,

            /// <summary>
            /// Pmax = 13.2 dBm.
            /// </summary>
            PMax13_2dBm = 0x04,

            /// <summary>
            /// Pmax = 13.8 dBm.
            /// </summary>
            PMax13_8dBm = 0x05,

            /// <summary>
            /// Pmax = 14.4 dBm.
            /// </summary>
            PMax14_4dBm = 0x06,

            /// <summary>
            /// Pmax = 15.0 dBm.
            /// </summary>
            PMax15_0dBm = 0x07
        }

        /// <summary>
        /// Output power.
        /// </summary>
        public enum OutputPowerEnum : byte
        {
            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 15 dBm. If PaBoostPin: 2 dBm.
            /// </summary>
            Level00 = 0x00,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 14 dBm. If PaBoostPin: 3 dBm.
            /// </summary>
            Level01 = 0x01,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 13 dBm. If PaBoostPin: 4 dBm.
            /// </summary>
            Level02 = 0x02,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 12 dBm. If PaBoostPin: 5 dBm.
            /// </summary>
            Level03 = 0x03,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 11 dBm. If PaBoostPin: 6 dBm.
            /// </summary>
            Level04 = 0x04,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 10 dBm. If PaBoostPin: 7 dBm.
            /// </summary>
            Level05 = 0x05,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 9 dBm. If PaBoostPin: 8 dBm.
            /// </summary>
            Level06 = 0x06,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 8 dBm. If PaBoostPin: 9 dBm.
            /// </summary>
            Level07 = 0x07,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 7 dBm. If PaBoostPin: 10 dBm.
            /// </summary>
            Level08 = 0x08,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 6 dBm. If PaBoostPin: 11 dBm.
            /// </summary>
            Level09 = 0x09,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 5 dBm. If PaBoostPin: 12 dBm.
            /// </summary>
            Level10 = 0x0A,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 4 dBm. If PaBoostPin: 13 dBm.
            /// </summary>
            Level11 = 0x0B,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 3 dBm. If PaBoostPin: 14 dBm.
            /// </summary>
            Level12 = 0x0C,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 2 dBm. If PaBoostPin: 15 dBm.
            /// </summary>
            Level13 = 0x0D,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm - 1 dBm. If PaBoostPin: 16 dBm.
            /// </summary>
            Level14 = 0x0E,

            /// <summary>
            /// The output power depends on PaSelect. If RfoPin: MaxPower dBm. If PaBoostPin: 17 dBm.
            /// </summary>
            Level15 = 0x0F
        }

        public CommonRegisterPaConfig(
            PaSelectEnum paSelect,
            MaxPowerEnum maxPower,
            OutputPowerEnum outputPower)
            : base(CommonRegisterAddress.PaConfig, 1)
        {
            // Assigning properties.
            PaSelect = paSelect;
            MaxPower = maxPower;
            OutputPower = outputPower;
        }

        public CommonRegisterPaConfig(byte registerValue)
            : base(CommonRegisterAddress.PaConfig, 1)
        {
            PaSelect = (PaSelectEnum)Enum.ToObject(typeof(PaSelectEnum), (byte)((registerValue & 0x80) >> 7));
            MaxPower = (MaxPowerEnum)Enum.ToObject(typeof(MaxPowerEnum), (byte)((registerValue & 0x70) >> 4));
            OutputPower = (OutputPowerEnum)Enum.ToObject(typeof(OutputPowerEnum), (byte)(registerValue & 0x0F));
        }

        internal CommonRegisterPaConfig(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterPaConfig Default = new CommonRegisterPaConfig(
            PaSelectEnum.RfoPin,
            MaxPowerEnum.PMax13_2dBm,
            OutputPowerEnum.Level15);

        /// <summary>
        /// Selects PA output pin
        /// </summary>
        public PaSelectEnum PaSelect { get; }

        /// <summary>
        /// Select max output power (10.8 - 15.0 dBm).
        /// </summary>
        public MaxPowerEnum MaxPower { get; }

        /// <summary>
        /// Output power.
        /// </summary>
        public OutputPowerEnum OutputPower { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)PaSelect << 7) & 0x80) | (byte)(((byte)MaxPower << 4) & 0x70) | (byte)((byte)OutputPower & 0x0F)) };
        }
    }

    /// <summary>
    /// Control of PA ramp time, low phase noise PLL.
    /// </summary>
    [Register((byte)CommonRegisterAddress.PaRamp, 1)]
    public class CommonRegisterPaRamp : CommonRegister
    {
        /// <summary>
        /// Rise/Fall time of ramp up/down in FSK.
        /// </summary>
        public enum PaRampEnum : byte
        {
            /// <summary>
            /// 3.4 ms Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_3400_us = 0x00,

            /// <summary>
            /// 2 ms Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_2000_us = 0x01,

            /// <summary>
            /// 1 ms Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_1000_us = 0x02,

            /// <summary>
            /// 500 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0500_us = 0x03,

            /// <summary>
            /// 250 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0250_us = 0x04,

            /// <summary>
            /// 125 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0125_us = 0x05,

            /// <summary>
            /// 100 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0100_us = 0x06,

            /// <summary>
            /// 62 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0062_us = 0x07,

            /// <summary>
            /// 50 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0050_us = 0x08,

            /// <summary>
            /// 40 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0040_us = 0x09,

            /// <summary>
            /// 31 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0031_us = 0x0A,

            /// <summary>
            /// 25 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0025_us = 0x0B,

            /// <summary>
            /// 20 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0020_us = 0x0C,

            /// <summary>
            /// 15 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0015_us = 0x0D,

            /// <summary>
            /// 12 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0012_us = 0x0E,

            /// <summary>
            /// 10 μs Rise/Fall time of ramp up/down in FSK.
            /// </summary>
            RampTime_0010_us = 0x0F
        }

        public CommonRegisterPaRamp(
            PaRampEnum paRamp)
            : base(CommonRegisterAddress.PaRamp, 1)
        {
            // Assigning properties.
            PaRamp = paRamp;
        }

        public CommonRegisterPaRamp(byte registerValue)
            : base(CommonRegisterAddress.PaRamp, 1)
        {
            PaRamp = (PaRampEnum)Enum.ToObject(typeof(PaRampEnum), (byte)(registerValue & 0x0F));
        }

        internal CommonRegisterPaRamp(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterPaRamp Default = new CommonRegisterPaRamp(PaRampEnum.RampTime_0040_us);

        /// <summary>
        /// Rise/Fall time of ramp up/down in FSK.
        /// </summary>
        public PaRampEnum PaRamp { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)PaRamp & 0x0F) };
        }
    }

    /// <summary>
    /// Over Current Protection control.
    /// </summary>
    [Register((byte)CommonRegisterAddress.Ocp, 1)]
    public class CommonRegisterOcp : CommonRegister
    {
        /// <summary>
        /// Enables overload current protection (OCP) for PA.
        /// </summary>
        public enum OcpOnEnum : byte
        {
            /// <summary>
            /// OCP disabled.
            /// </summary>
            OcpDisabled = 0x00,

            /// <summary>
            /// OCP enabled.
            /// </summary>
            OcpEnabled = 0x01
        }

        /// <summary>
        /// Trimming of OCP current.
        /// </summary>
        public enum OcpTrimEnum : byte
        {
            /// <summary>
            /// IMax = 45 mA.
            /// </summary>
            IMax_045_mA = 0x00,

            /// <summary>
            /// IMax = 50 mA.
            /// </summary>
            IMax_050_mA = 0x01,

            /// <summary>
            /// IMax = 55 mA.
            /// </summary>
            IMax_055_mA = 0x02,

            /// <summary>
            /// IMax = 60 mA.
            /// </summary>
            IMax_060_mA = 0x03,

            /// <summary>
            /// IMax = 65 mA.
            /// </summary>
            IMax_065_mA = 0x04,

            /// <summary>
            /// IMax = 70 mA.
            /// </summary>
            IMax_070_mA = 0x05,

            /// <summary>
            /// IMax = 75 mA.
            /// </summary>
            IMax_075_mA = 0x06,

            /// <summary>
            /// IMax = 80 mA.
            /// </summary>
            IMax_080_mA = 0x07,

            /// <summary>
            /// IMax = 85 mA.
            /// </summary>
            IMax_085_mA = 0x08,

            /// <summary>
            /// IMax = 90 mA.
            /// </summary>
            IMax_090_mA = 0x09,

            /// <summary>
            /// IMax = 95 mA.
            /// </summary>
            IMax_095_mA = 0x0A,

            /// <summary>
            /// IMax = 100 mA.
            /// </summary>
            IMax_100_mA = 0x0B,

            /// <summary>
            /// IMax = 105 mA.
            /// </summary>
            IMax_105_mA = 0x0C,

            /// <summary>
            /// IMax = 110 mA.
            /// </summary>
            IMax_110_mA = 0x0D,

            /// <summary>
            /// IMax = 115 mA.
            /// </summary>
            IMax_115_mA = 0x0E,

            /// <summary>
            /// IMax = 120 mA.
            /// </summary>
            IMax_120_mA = 0x0F,

            /// <summary>
            /// IMax = 130 mA.
            /// </summary>
            IMax_130_mA = 0x10,

            /// <summary>
            /// IMax = 140 mA.
            /// </summary>
            IMax_140_mA = 0x11,

            /// <summary>
            /// IMax = 150 mA.
            /// </summary>
            IMax_150_mA = 0x12,

            /// <summary>
            /// IMax = 160 mA.
            /// </summary>
            IMax_160_mA = 0x13,

            /// <summary>
            /// IMax = 170 mA.
            /// </summary>
            IMax_170_mA = 0x14,

            /// <summary>
            /// IMax = 180 mA.
            /// </summary>
            IMax_180_mA = 0x15,

            /// <summary>
            /// IMax = 190 mA.
            /// </summary>
            IMax_190_mA = 0x16,

            /// <summary>
            /// IMax = 200 mA.
            /// </summary>
            IMax_200_mA = 0x17,

            /// <summary>
            /// IMax = 210 mA.
            /// </summary>
            IMax_210_mA = 0x18,

            /// <summary>
            /// IMax = 220 mA.
            /// </summary>
            IMax_220_mA = 0x19,

            /// <summary>
            /// IMax = 230 mA.
            /// </summary>
            IMax_230_mA = 0x1A,

            /// <summary>
            /// IMax = 240 mA.
            /// </summary>
            IMax_240_mA = 0x1B,

            /// <summary>
            /// IMax = 250 mA.
            /// </summary>
            IMax_250_mA = 0x1C,

            /// <summary>
            /// IMax = 260 mA.
            /// </summary>
            IMax_260_mA = 0x1D,

            /// <summary>
            /// IMax = 270 mA.
            /// </summary>
            IMax_270_mA = 0x1E,

            /// <summary>
            /// IMax = 280 mA.
            /// </summary>
            IMax_280_mA = 0x1F
        }

        public CommonRegisterOcp(
            OcpOnEnum ocpOn,
            OcpTrimEnum ocpTrim)
            : base(CommonRegisterAddress.Ocp, 1)
        {
            // Assigning properties.
            OcpOn = ocpOn;
            OcpTrim = ocpTrim;
        }

        public CommonRegisterOcp(byte registerValue)
            : base(CommonRegisterAddress.Ocp, 1)
        {
            OcpOn = (OcpOnEnum)Enum.ToObject(typeof(OcpOnEnum), (byte)((registerValue & 0x20) >> 5));
            OcpTrim = (OcpTrimEnum)Enum.ToObject(typeof(OcpTrimEnum), (byte)(registerValue & 0x1F));
        }

        internal CommonRegisterOcp(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterOcp Default = new CommonRegisterOcp(
            OcpOnEnum.OcpEnabled,
            OcpTrimEnum.IMax_100_mA);

        /// <summary>
        /// Enables overload current protection (OCP) for PA.
        /// </summary>
        public OcpOnEnum OcpOn { get; }

        /// <summary>
        /// Trimming of OCP current.
        /// </summary>
        public OcpTrimEnum OcpTrim { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)OcpOn << 5) & 0x20) | (byte)((byte)OcpTrim & 0x1F)) };
        }
    }

    /// <summary>
    /// LNA settings.
    /// </summary>
    [Register((byte)CommonRegisterAddress.Lna, 1)]
    public class CommonRegisterLna : CommonRegister
    {
        /// <summary>
        /// LNA gain setting.
        /// </summary>
        public enum LnaGainEnum : byte
        {
            /// <summary>
            /// Not used.
            /// </summary>
            NotUsed = 0x00,

            /// <summary>
            /// G1 = Maximum gain.
            /// </summary>
            G1Max = 0x01,

            /// <summary>
            /// G2 = Second highest gain.
            /// </summary>
            G2 = 0x02,

            /// <summary>
            /// G3 = Medium high gain.
            /// </summary>
            G3 = 0x03,

            /// <summary>
            /// G4 = Medium low gain.
            /// </summary>
            G4 = 0x04,

            /// <summary>
            /// G5 = Second lowest gain.
            /// </summary>
            G5 = 0x05,

            /// <summary>
            /// G6 = Minimum gain.
            /// </summary>
            G6Min = 0x06,

            /// <summary>
            /// Not used.
            /// </summary>
            NotUsed2 = 0x07
        }

        /// <summary>
        /// Low Frequency (RFI_LF) LNA current adjustment.
        /// </summary>
        public enum LnaBoostLfEnum : byte
        {
            /// <summary>
            /// Default LNA current.
            /// </summary>
            DefaultLnaCurrent = 0x00
        }

        /// <summary>
        /// High Frequency (RFI_HF) LNA current adjustment.
        /// </summary>
        public enum LnaBoostHfEnum : byte
        {
            /// <summary>
            /// Default LNA current.
            /// </summary>
            DefaultLnaCurrent = 0x00,

            /// <summary>
            /// Boost on, 150% LNA current.
            /// </summary>
            BoostOn = 0x03
        }

        public CommonRegisterLna(
            LnaGainEnum lnaGain,
            LnaBoostLfEnum lnaBoostLf,
            LnaBoostHfEnum lnaBoostHf)
            : base(CommonRegisterAddress.Lna, 1)
        {
            // Assigning properties.
            LnaGain = lnaGain;
            LnaBoostLf = lnaBoostLf;
            LnaBoostHf = lnaBoostHf;
        }

        public CommonRegisterLna(byte registerValue)
            : base(CommonRegisterAddress.Lna, 1)
        {
            LnaGain = (LnaGainEnum)Enum.ToObject(typeof(LnaGainEnum), (byte)((registerValue & 0xE0) >> 5));
            LnaBoostLf = (LnaBoostLfEnum)Enum.ToObject(typeof(LnaBoostLfEnum), (byte)((registerValue & 0x18) >> 3));
            LnaBoostHf = (LnaBoostHfEnum)Enum.ToObject(typeof(LnaBoostHfEnum), (byte)(registerValue & 0x03));
        }

        internal CommonRegisterLna(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterLna Default = new CommonRegisterLna(
            LnaGainEnum.G1Max,
            LnaBoostLfEnum.DefaultLnaCurrent,
            LnaBoostHfEnum.DefaultLnaCurrent);

        /// <summary>
        /// LNA gain setting.
        /// </summary>
        public LnaGainEnum LnaGain { get; }

        /// <summary>
        /// Low Frequency (RFI_LF) LNA current adjustment.
        /// </summary>
        public LnaBoostLfEnum LnaBoostLf { get; }

        /// <summary>
        /// High Frequency (RFI_HF) LNA current adjustment.
        /// </summary>
        public LnaBoostHfEnum LnaBoostHf { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)LnaGain << 5) & 0xE0) | (byte)(((byte)LnaBoostLf << 3) & 0x18) | (byte)((byte)LnaBoostHf & 0x03)) };
        }
    }

    /// <summary>
    /// Mapping of pins DIO0 to DIO3.
    /// </summary>
    [Register((byte)CommonRegisterAddress.DioMapping1, 1)]
    public class CommonRegisterDioMapping1 : CommonRegister
    {
        /// <summary>
        /// Mapping of pins DIO0.
        /// </summary>
        public enum Dio0MappingEnum : byte
        {
            RxDone = 0x00,
            TxDone = 0x01,
            CadDone = 0x02
        }

        /// <summary>
        /// Mapping of pins DIO1.
        /// </summary>
        public enum Dio1MappingEnum : byte
        {
            RxTimeout = 0x00,
            FhssChangeChannel = 0x01,
            CadDetected = 0x02
        }

        /// <summary>
        /// Mapping of pins DIO2.
        /// </summary>
        public enum Dio2MappingEnum : byte
        {
            FhssChangeChannel1 = 0x00,
            FhssChangeChannel2 = 0x01,
            FhssChangeChannel3 = 0x02
        }

        /// <summary>
        /// Mapping of pins DIO3.
        /// </summary>
        public enum Dio3MappingEnum : byte
        {
            CadDone = 0x00,
            ValidHeader = 0x01,
            PayloadCrcError = 0x02
        }

        public CommonRegisterDioMapping1(
            Dio0MappingEnum dio0Mapping,
            Dio1MappingEnum dio1Mapping,
            Dio2MappingEnum dio2Mapping,
            Dio3MappingEnum dio3Mapping)
            : base(CommonRegisterAddress.DioMapping1, 1)
        {
            // Assigning properties.
            Dio0Mapping = dio0Mapping;
            Dio1Mapping = dio1Mapping;
            Dio2Mapping = dio2Mapping;
            Dio3Mapping = dio3Mapping;
        }

        public CommonRegisterDioMapping1(byte registerValue)
            : base(CommonRegisterAddress.DioMapping1, 1)
        {
            Dio0Mapping = (Dio0MappingEnum)Enum.ToObject(typeof(Dio0MappingEnum), (byte)((registerValue & 0xC0) >> 6));
            Dio1Mapping = (Dio1MappingEnum)Enum.ToObject(typeof(Dio1MappingEnum), (byte)((registerValue & 0x30) >> 4));
            Dio2Mapping = (Dio2MappingEnum)Enum.ToObject(typeof(Dio2MappingEnum), (byte)((registerValue & 0x0C) >> 2));
            Dio3Mapping = (Dio3MappingEnum)Enum.ToObject(typeof(Dio3MappingEnum), (byte)(registerValue & 0x03));
        }

        internal CommonRegisterDioMapping1(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterDioMapping1 Default = new CommonRegisterDioMapping1(
            Dio0MappingEnum.RxDone,
            Dio1MappingEnum.RxTimeout,
            Dio2MappingEnum.FhssChangeChannel1,
            Dio3MappingEnum.CadDone);

        /// <summary>
        /// Mapping of pins DIO0.
        /// </summary>
        public Dio0MappingEnum Dio0Mapping { get; }

        /// <summary>
        /// Mapping of pins DIO1.
        /// </summary>
        public Dio1MappingEnum Dio1Mapping { get; }

        /// <summary>
        /// Mapping of pins DIO2.
        /// </summary>
        public Dio2MappingEnum Dio2Mapping { get; }

        /// <summary>
        /// Mapping of pins DIO3.
        /// </summary>
        public Dio3MappingEnum Dio3Mapping { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)Dio0Mapping << 6) & 0xC0) | (byte)(((byte)Dio1Mapping << 4) & 0x30) | (byte)(((byte)Dio2Mapping << 2) & 0x0C) | (byte)((byte)Dio3Mapping & 0x03)) };
        }
    }

    /// <summary>
    /// Mapping of pins DIO4 and DIO5, ClkOut frequency.
    /// </summary>
    [Register((byte)CommonRegisterAddress.DioMapping2, 1)]
    public class CommonRegisterDioMapping2 : CommonRegister
    {
        /// <summary>
        /// Mapping of pins DIO4.
        /// </summary>
        public enum Dio4MappingEnum : byte
        {
            CadDetected = 0x00,
            PllLock1 = 0x01,
            PllLock2 = 0x02
        }

        /// <summary>
        /// Mapping of pins DIO5.
        /// </summary>
        public enum Dio5MappingEnum : byte
        {
            ModeReady = 0x00,
            ClkOut1 = 0x01,
            ClkOut2 = 0x02
        }

        /// <summary>
        /// Allows the mapping of either Rssi Or PreambleDetect to the DIO pins.
        /// </summary>
        public enum MapPreambleDetectEnum : byte
        {
            /// <summary>
            /// Rssi interrupt.
            /// </summary>
            RssiInterrupt = 0x00,

            /// <summary>
            /// PreambleDetect interrupt.
            /// </summary>
            PreambleDetectInterrupt = 0x01
        }

        public CommonRegisterDioMapping2(
            Dio4MappingEnum dio4Mapping,
            Dio5MappingEnum dio5Mapping,
            MapPreambleDetectEnum mapPreambleDetect)
            : base(CommonRegisterAddress.DioMapping2, 1)
        {
            // Assigning properties.
            Dio4Mapping = dio4Mapping;
            Dio5Mapping = dio5Mapping;
            MapPreambleDetect = mapPreambleDetect;
        }

        public CommonRegisterDioMapping2(byte registerValue)
            : base(CommonRegisterAddress.DioMapping2, 1)
        {
            Dio4Mapping = (Dio4MappingEnum)Enum.ToObject(typeof(Dio4MappingEnum), (byte)((registerValue & 0xC0) >> 6));
            Dio5Mapping = (Dio5MappingEnum)Enum.ToObject(typeof(Dio5MappingEnum), (byte)((registerValue & 0x30) >> 4));
            MapPreambleDetect = (MapPreambleDetectEnum)Enum.ToObject(typeof(MapPreambleDetectEnum), (byte)(registerValue & 0x01));
        }

        internal CommonRegisterDioMapping2(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterDioMapping2 Default = new CommonRegisterDioMapping2(
            Dio4MappingEnum.CadDetected,
            Dio5MappingEnum.ModeReady,
            MapPreambleDetectEnum.RssiInterrupt);

        /// <summary>
        /// Mapping of pins DIO4.
        /// </summary>
        public Dio4MappingEnum Dio4Mapping { get; }

        /// <summary>
        /// Mapping of pins DIO5.
        /// </summary>
        public Dio5MappingEnum Dio5Mapping { get; }

        /// <summary>
        /// Allows the mapping of either Rssi Or PreambleDetect to the DIO pins.
        /// </summary>
        public MapPreambleDetectEnum MapPreambleDetect { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)Dio4Mapping << 6) & 0xC0) | (byte)(((byte)Dio5Mapping << 4) & 0x30) | (byte)((byte)MapPreambleDetect & 0x01)) };
        }
    }

    /// <summary>
    /// Semtech ID relating the silicon revision.
    /// </summary>
    [Register((byte)CommonRegisterAddress.Version, 1)]
    public class CommonRegisterVersion : CommonRegister
    {
        public CommonRegisterVersion(byte value)
            : base(CommonRegisterAddress.Version, 1)
        {
            // Assigning properties.
            Value = value;
        }

        internal CommonRegisterVersion(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterVersion Default = new CommonRegisterVersion(0x12);

        public byte Value { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { Value };
        }
    }

    /// <summary>
    /// TCXO or XTAL input setting.
    /// </summary>
    [Register((byte)CommonRegisterAddress.Tcxo, 1)]
    public class CommonRegisterTcxo : CommonRegister
    {
        public CommonRegisterTcxo(byte value)
            : base(CommonRegisterAddress.Tcxo, 1)
        {
            // Assigning properties.
            Value = value;
        }

        internal CommonRegisterTcxo(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterTcxo Default = new CommonRegisterTcxo(0x09);

        public byte Value { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { Value };
        }
    }

    /// <summary>
    /// Higher power settings of the PA.
    /// </summary>
    [Register((byte)CommonRegisterAddress.PaDac, 1)]
    public class CommonRegisterPaDac : CommonRegister
    {
        /// <summary>
        /// Reserved. Retain default value.
        /// </summary>
        public enum ReservedEnum : byte
        {
            /// <summary>
            /// Default.
            /// </summary>
            Default = 0x10
        }

        /// <summary>
        /// Enables the +20dBm option on PA_BOOST pin.
        /// </summary>
        public enum PaDacEnum : byte
        {
            /// <summary>
            /// Default value.
            /// </summary>
            Default = 0x04,

            /// <summary>
            /// +20dBm on PA_BOOST when OutputPower=1111.
            /// </summary>
            Boost = 0x07
        }

        public CommonRegisterPaDac(
            ReservedEnum reserved,
            PaDacEnum paDac)
            : base(CommonRegisterAddress.PaDac, 1)
        {
            // Assigning properties.
            Reserved = reserved;
            PaDac = paDac;
        }

        public CommonRegisterPaDac(byte registerValue)
            : base(CommonRegisterAddress.PaDac, 1)
        {
            Reserved = (ReservedEnum)Enum.ToObject(typeof(ReservedEnum), (byte)((registerValue & 0xF8) >> 3));
            PaDac = (PaDacEnum)Enum.ToObject(typeof(PaDacEnum), (byte)(registerValue & 0x07));
        }

        internal CommonRegisterPaDac(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterPaDac Default = new CommonRegisterPaDac(
            ReservedEnum.Default,
            PaDacEnum.Default);

        /// <summary>
        /// Reserved. Retain default value.
        /// </summary>
        public ReservedEnum Reserved { get; }

        /// <summary>
        /// Enables the +20dBm option on PA_BOOST pin.
        /// </summary>
        public PaDacEnum PaDac { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)Reserved << 3) & 0xF8) | (byte)((byte)PaDac & 0x07)) };
        }
    }

    /// <summary>
    /// Stored temperature during the former IQ Calibration.
    /// </summary>
    [Register((byte)CommonRegisterAddress.FormerTemp, 1)]
    public class CommonRegisterFormerTemp : CommonRegister
    {
        public CommonRegisterFormerTemp(byte value)
            : base(CommonRegisterAddress.FormerTemp, 1)
        {
            // Assigning properties.
            Value = value;
        }

        internal CommonRegisterFormerTemp(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterFormerTemp Default = new CommonRegisterFormerTemp(0x00);

        public byte Value { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { Value };
        }
    }

    /// <summary>
    /// Adjustment of the AGC thresholds.
    /// </summary>
    [Register((byte)CommonRegisterAddress.AgcRef, 1)]
    public class CommonRegisterAgcRef : CommonRegister
    {
        public CommonRegisterAgcRef(byte value, bool isRegisterValue)
            : base(CommonRegisterAddress.AgcRef, 1)
        {
            if (isRegisterValue)
            {
                // Assigning the composed numerical value.
                AgcReferenceLevel = (byte)(value & 0x3F);
            }
            else
            {
                // Validating the numerical range.
                if (value > 0x3F)
                {
                    throw new ArgumentException($"{nameof(value)} must be in the range of [0x00 - 0x3F].");
                }

                // Assigning properties.
                AgcReferenceLevel = value;
            }
        }

        internal CommonRegisterAgcRef(byte[] registerValues)
            : this(registerValues[0], true)
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterAgcRef Default = new CommonRegisterAgcRef(
            0x19,
            false);

        /// <summary>
        /// Sets the floor reference for all AGC thresholds: AGC Reference[dBm]=-174dBm+10*log(2*RxBw)+SNR+AgcReferenceLevel, SNR = 8dB, fixed value.
        /// </summary>
        public byte AgcReferenceLevel { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)(AgcReferenceLevel & 0x3F) };
        }
    }

    /// <summary>
    /// Adjustment of the AGC thresholds.
    /// </summary>
    [Register((byte)CommonRegisterAddress.AgcThresh1, 1)]
    public class CommonRegisterAgcThresh1 : CommonRegister
    {
        public CommonRegisterAgcThresh1(byte value, bool isRegisterValue)
            : base(CommonRegisterAddress.AgcThresh1, 1)
        {
            if (isRegisterValue)
            {
                // Assigning the composed numerical value.
                AgcStep1 = (byte)(value & 0x1F);
            }
            else
            {
                // Validating the numerical range.
                if (value > 0x1F)
                {
                    throw new ArgumentException($"{nameof(value)} must be in the range of [0x00 - 0x1F].");
                }

                // Assigning properties.
                AgcStep1 = value;
            }
        }

        internal CommonRegisterAgcThresh1(byte[] registerValues)
            : this(registerValues[0], true)
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterAgcThresh1 Default = new CommonRegisterAgcThresh1(
            0x0C,
            false);

        /// <summary>
        /// Defines the 1st AGC Threshold.
        /// </summary>
        public byte AgcStep1 { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)(AgcStep1 & 0x1F) };
        }
    }

    /// <summary>
    /// Adjustment of the AGC thresholds.
    /// </summary>
    [Register((byte)CommonRegisterAddress.AgcThresh2, 1)]
    public class CommonRegisterAgcThresh2 : CommonRegister
    {
        public CommonRegisterAgcThresh2(
            byte agcStep2,
            byte agcStep3)
            : base(CommonRegisterAddress.AgcThresh2, 1)
        {
            // Validating the numerical range.
            if (agcStep2 > 0xF)
            {
                throw new ArgumentException($"{nameof(agcStep2)} must be in the range of [0x0 - 0xF].");
            }

            // Validating the numerical range.
            if (agcStep3 > 0xF)
            {
                throw new ArgumentException($"{nameof(agcStep3)} must be in the range of [0x0 - 0xF].");
            }

            // Assigning properties.
            AgcStep2 = agcStep2;
            AgcStep3 = agcStep3;
        }

        public CommonRegisterAgcThresh2(byte registerValue)
            : base(CommonRegisterAddress.AgcThresh2, 1)
        {
            // Assigning the composed numerical value.
            AgcStep2 = (byte)((registerValue & 0xF0) >> 4);
            // Assigning the composed numerical value.
            AgcStep3 = (byte)(registerValue & 0x0F);
        }

        internal CommonRegisterAgcThresh2(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterAgcThresh2 Default = new CommonRegisterAgcThresh2(
            0x40,
            0xB);

        /// <summary>
        /// Defines the 2nd AGC Threshold.
        /// </summary>
        public byte AgcStep2 { get; }

        /// <summary>
        /// Defines the 3rd AGC Threshold.
        /// </summary>
        public byte AgcStep3 { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)((AgcStep2 << 4) & 0xF0) | (byte)(AgcStep3 & 0x0F)) };
        }
    }

    /// <summary>
    /// Adjustment of the AGC thresholds.
    /// </summary>
    [Register((byte)CommonRegisterAddress.AgcThresh3, 1)]
    public class CommonRegisterAgcThresh3 : CommonRegister
    {
        public CommonRegisterAgcThresh3(
            byte agcStep4,
            byte agcStep5)
            : base(CommonRegisterAddress.AgcThresh3, 1)
        {
            // Validating the numerical range.
            if (agcStep4 > 0xF)
            {
                throw new ArgumentException($"{nameof(agcStep4)} must be in the range of [0x0 - 0xF].");
            }

            // Validating the numerical range.
            if (agcStep5 > 0xF)
            {
                throw new ArgumentException($"{nameof(agcStep5)} must be in the range of [0x0 - 0xF].");
            }

            // Assigning properties.
            AgcStep4 = agcStep4;
            AgcStep5 = agcStep5;
        }

        public CommonRegisterAgcThresh3(byte registerValue)
            : base(CommonRegisterAddress.AgcThresh3, 1)
        {
            // Assigning the composed numerical value.
            AgcStep4 = (byte)((registerValue & 0xF0) >> 4);
            // Assigning the composed numerical value.
            AgcStep5 = (byte)(registerValue & 0x0F);
        }

        internal CommonRegisterAgcThresh3(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterAgcThresh3 Default = new CommonRegisterAgcThresh3(
            0xC0,
            0xC);

        /// <summary>
        /// Defines the 4th AGC Threshold.
        /// </summary>
        public byte AgcStep4 { get; }

        /// <summary>
        /// Defines the 5th AGC Threshold.
        /// </summary>
        public byte AgcStep5 { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)((AgcStep4 << 4) & 0xF0) | (byte)(AgcStep5 & 0x0F)) };
        }
    }

    /// <summary>
    /// Control of the PLL bandwidth.
    /// </summary>
    [Register((byte)CommonRegisterAddress.Pll, 1)]
    public class CommonRegisterPll : CommonRegister
    {
        /// <summary>
        /// Controls the PLL bandwidth.
        /// </summary>
        public enum PllBandwidthEnum : byte
        {
            /// <summary>
            /// 75 kHz
            /// </summary>
            Pll_075_kHz = 0x00,

            /// <summary>
            /// 150 kHz
            /// </summary>
            Pll_150_kHz = 0x01,

            /// <summary>
            /// 225 kHz
            /// </summary>
            Pll_225_kHz = 0x02,

            /// <summary>
            /// 300 kHz
            /// </summary>
            Pll_300_kHz = 0x03
        }

        public CommonRegisterPll(
            PllBandwidthEnum pllBandwidth)
            : base(CommonRegisterAddress.Pll, 1)
        {
            // Assigning properties.
            PllBandwidth = pllBandwidth;
        }

        public CommonRegisterPll(byte registerValue)
            : base(CommonRegisterAddress.Pll, 1)
        {
            PllBandwidth = (PllBandwidthEnum)Enum.ToObject(typeof(PllBandwidthEnum), (byte)((registerValue & 0xC0) >> 6));
        }

        internal CommonRegisterPll(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly CommonRegisterPll Default = new CommonRegisterPll(PllBandwidthEnum.Pll_075_kHz);

        /// <summary>
        /// Controls the PLL bandwidth.
        /// </summary>
        public PllBandwidthEnum PllBandwidth { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)(((byte)PllBandwidth << 6) & 0xC0) };
        }
    }

    public enum FskRegisterAddress
    {
        /// <summary>
        /// Image calibration engine control.
        /// </summary>
        ImageCal = 0x3B,

        /// <summary>
        /// Temperature Sensor value.
        /// </summary>
        Temp = 0x3C,

        /// <summary>
        /// Low Battery Indicator Settings.
        /// </summary>
        LowBat = 0x3D
    }

    public abstract class FskRegister : Register
    {
        internal FskRegister(FskRegisterAddress address, byte length)
            : base((byte)address, length)
        {
        }
    }

    /// <summary>
    /// Image calibration engine control.
    /// </summary>
    [Register((byte)FskRegisterAddress.ImageCal, 1)]
    public class FskRegisterImageCal : FskRegister
    {
        /// <summary>
        /// Controls the Image calibration mechanism.
        /// </summary>
        public enum AutoImageCalOnEnum : byte
        {
            /// <summary>
            /// Calibration of the receiver depending on the temperature is disabled.
            /// </summary>
            Disabled = 0x00,

            /// <summary>
            /// Calibration of the receiver depending on the temperature enabled.
            /// </summary>
            Enabled = 0x01
        }

        /// <summary>
        /// Triggers the IQ and RSSI calibration when set in Standby mode.
        /// </summary>
        public enum ImageCalStartEnum : byte
        {
            /// <summary>
            /// Idle.
            /// </summary>
            Idle = 0x00,

            /// <summary>
            /// Triggers the IQ and RSSI calibration when set in Standby mode.
            /// </summary>
            Start = 0x01
        }

        /// <summary>
        /// Set to <see cref="Run"/> while the Image and RSSI calibration are running. Toggles back to <see cref="Idle"/> when the process is completed.
        /// </summary>
        public enum ImageCalRunningEnum : byte
        {
            /// <summary>
            /// Idle.
            /// </summary>
            Idle = 0x00,

            /// <summary>
            /// Set to this while the Image and RSSI calibration are running.
            /// </summary>
            Run = 0x01
        }

        /// <summary>
        /// IRQ flag witnessing a temperature change exceeding. TempThreshold since the last Image and RSSI calibration.
        /// </summary>
        public enum TempChangeEnum : byte
        {
            /// <summary>
            /// Temperature change lower than TempThreshold.
            /// </summary>
            LowerThanThreshold = 0x00,

            /// <summary>
            /// Temperature change greater than TempThreshold.
            /// </summary>
            HigherThanThreshold = 0x01
        }

        /// <summary>
        /// Temperature change threshold to trigger a new I/Q calibration.
        /// </summary>
        public enum TempThresholdEnum : byte
        {
            /// <summary>
            /// Temperature change threshold 5 °C.
            /// </summary>
            Threshold_05C = 0x00,

            /// <summary>
            /// Temperature change threshold 10 °C.
            /// </summary>
            Threshold_10C = 0x01,

            /// <summary>
            /// Temperature change threshold 15 °C.
            /// </summary>
            Threshold_15C = 0x02,

            /// <summary>
            /// Temperature change threshold 20 °C.
            /// </summary>
            Threshold_20C = 0x03
        }

        /// <summary>
        /// Controls the temperature monitor operation.
        /// </summary>
        public enum TempMonitorActiveEnum : byte
        {
            /// <summary>
            /// Temperature monitoring done in all modes except Sleep and Standby.
            /// </summary>
            Monitoring = 0x00,

            /// <summary>
            /// Temperature monitoring stopped.
            /// </summary>
            Stopped = 0x01
        }

        public FskRegisterImageCal(
            AutoImageCalOnEnum autoImageCalOn,
            ImageCalStartEnum imageCalStart,
            ImageCalRunningEnum imageCalRunning,
            TempChangeEnum tempChange,
            TempThresholdEnum tempThreshold,
            TempMonitorActiveEnum tempMonitorActive)
            : base(FskRegisterAddress.ImageCal, 1)
        {
            // Assigning properties.
            AutoImageCalOn = autoImageCalOn;
            ImageCalStart = imageCalStart;
            ImageCalRunning = imageCalRunning;
            TempChange = tempChange;
            TempThreshold = tempThreshold;
            TempMonitorActive = tempMonitorActive;
        }

        public FskRegisterImageCal(byte registerValue)
            : base(FskRegisterAddress.ImageCal, 1)
        {
            AutoImageCalOn = (AutoImageCalOnEnum)Enum.ToObject(typeof(AutoImageCalOnEnum), (byte)((registerValue & 0x80) >> 7));
            ImageCalStart = (ImageCalStartEnum)Enum.ToObject(typeof(ImageCalStartEnum), (byte)((registerValue & 0x40) >> 6));
            ImageCalRunning = (ImageCalRunningEnum)Enum.ToObject(typeof(ImageCalRunningEnum), (byte)((registerValue & 0x20) >> 5));
            TempChange = (TempChangeEnum)Enum.ToObject(typeof(TempChangeEnum), (byte)((registerValue & 0x08) >> 3));
            TempThreshold = (TempThresholdEnum)Enum.ToObject(typeof(TempThresholdEnum), (byte)((registerValue & 0x06) >> 1));
            TempMonitorActive = (TempMonitorActiveEnum)Enum.ToObject(typeof(TempMonitorActiveEnum), (byte)(registerValue & 0x01));
        }

        internal FskRegisterImageCal(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly FskRegisterImageCal Default = new FskRegisterImageCal(
            AutoImageCalOnEnum.Disabled,
            ImageCalStartEnum.Idle,
            ImageCalRunningEnum.Idle,
            TempChangeEnum.LowerThanThreshold,
            TempThresholdEnum.Threshold_10C,
            TempMonitorActiveEnum.Monitoring);

        /// <summary>
        /// Controls the Image calibration mechanism.
        /// </summary>
        public AutoImageCalOnEnum AutoImageCalOn { get; }

        /// <summary>
        /// Triggers the IQ and RSSI calibration when set in Standby mode.
        /// </summary>
        public ImageCalStartEnum ImageCalStart { get; }

        /// <summary>
        /// Set to <see cref="Run"/> while the Image and RSSI calibration are running. Toggles back to <see cref="Idle"/> when the process is completed.
        /// </summary>
        public ImageCalRunningEnum ImageCalRunning { get; }

        /// <summary>
        /// IRQ flag witnessing a temperature change exceeding. TempThreshold since the last Image and RSSI calibration.
        /// </summary>
        public TempChangeEnum TempChange { get; }

        /// <summary>
        /// Temperature change threshold to trigger a new I/Q calibration.
        /// </summary>
        public TempThresholdEnum TempThreshold { get; }

        /// <summary>
        /// Controls the temperature monitor operation.
        /// </summary>
        public TempMonitorActiveEnum TempMonitorActive { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)AutoImageCalOn << 7) & 0x80) | (byte)(((byte)ImageCalStart << 6) & 0x40) | (byte)(((byte)ImageCalRunning << 5) & 0x20) | (byte)(((byte)TempChange << 3) & 0x08) | (byte)(((byte)TempThreshold << 1) & 0x06) | (byte)((byte)TempMonitorActive & 0x01)) };
        }
    }

    /// <summary>
    /// Temperature Sensor value.
    /// </summary>
    [Register((byte)FskRegisterAddress.Temp, 1)]
    public class FskRegisterTemp : FskRegister
    {
        public FskRegisterTemp(byte value)
            : base(FskRegisterAddress.Temp, 1)
        {
            // Assigning properties.
            Value = value;
        }

        internal FskRegisterTemp(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Temperature Sensor value.
        /// </summary>
        public byte Value { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { Value };
        }
    }

    /// <summary>
    /// Low Battery Indicator Settings.
    /// </summary>
    [Register((byte)FskRegisterAddress.LowBat, 1)]
    public class FskRegisterLowBat : FskRegister
    {
        /// <summary>
        /// Low Battery detector enable signal.
        /// </summary>
        public enum LowBatOnEnum : byte
        {
            /// <summary>
            /// LowBat detector disabled.
            /// </summary>
            Disabled = 0x00,

            /// <summary>
            /// LowBat detector enabled.
            /// </summary>
            Enabled = 0x01
        }

        /// <summary>
        /// Trimming of the LowBat threshold.
        /// </summary>
        public enum LowBatTrimEnum : byte
        {
            /// <summary>
            /// LowBat threshold 1.695 V.
            /// </summary>
            Threshold_1_695V = 0x00,

            /// <summary>
            /// LowBat threshold 1.764 V.
            /// </summary>
            Threshold_1_764V = 0x01,

            /// <summary>
            /// LowBat threshold 1.835 V.
            /// </summary>
            Threshold_1_835V = 0x02,

            /// <summary>
            /// LowBat threshold 1.905 V.
            /// </summary>
            Threshold_1_905V = 0x03,

            /// <summary>
            /// LowBat threshold 1.976 V.
            /// </summary>
            Threshold_1_976V = 0x04,

            /// <summary>
            /// LowBat threshold 2.045 V.
            /// </summary>
            Threshold_2_045V = 0x05,

            /// <summary>
            /// LowBat threshold 2.116 V.
            /// </summary>
            Threshold_2_116V = 0x06,

            /// <summary>
            /// LowBat threshold 2.185 V.
            /// </summary>
            Threshold_2_185V = 0x07
        }

        public FskRegisterLowBat(
            LowBatOnEnum lowBatOn,
            LowBatTrimEnum lowBatTrim)
            : base(FskRegisterAddress.LowBat, 1)
        {
            // Assigning properties.
            LowBatOn = lowBatOn;
            LowBatTrim = lowBatTrim;
        }

        public FskRegisterLowBat(byte registerValue)
            : base(FskRegisterAddress.LowBat, 1)
        {
            LowBatOn = (LowBatOnEnum)Enum.ToObject(typeof(LowBatOnEnum), (byte)((registerValue & 0x08) >> 3));
            LowBatTrim = (LowBatTrimEnum)Enum.ToObject(typeof(LowBatTrimEnum), (byte)(registerValue & 0x07));
        }

        internal FskRegisterLowBat(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly FskRegisterLowBat Default = new FskRegisterLowBat(
            LowBatOnEnum.Disabled,
            LowBatTrimEnum.Threshold_1_835V);

        /// <summary>
        /// Low Battery detector enable signal.
        /// </summary>
        public LowBatOnEnum LowBatOn { get; }

        /// <summary>
        /// Trimming of the LowBat threshold.
        /// </summary>
        public LowBatTrimEnum LowBatTrim { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)LowBatOn << 3) & 0x08) | (byte)((byte)LowBatTrim & 0x07)) };
        }
    }

    public enum LoraRegisterAddress
    {
        /// <summary>
        /// FIFO SPI pointer.
        /// </summary>
        FifoAddrPtr = 0x0D,

        /// <summary>
        /// Start Tx data.
        /// </summary>
        FifoTxBaseAddr = 0x0E,

        /// <summary>
        /// Start Rx data.
        /// </summary>
        FifoRxBaseAddr = 0x0F,

        /// <summary>
        /// Start address of last packet received.
        /// </summary>
        FifoRxCurrentAddr = 0x10,

        /// <summary>
        /// Optional IRQ flag mask.
        /// </summary>
        IrqFlagsMask = 0x11,

        /// <summary>
        /// IRQ flags.
        /// </summary>
        IrqFlags = 0x12,

        /// <summary>
        /// Number of received bytes.
        /// </summary>
        RxNbBytes = 0x13,

        /// <summary>
        /// Number of valid headers received.
        /// </summary>
        RxHeaderCntValue = 0x14,

        /// <summary>
        /// Number of valid packets received.
        /// </summary>
        RxPacketCntValue = 0x16,

        /// <summary>
        /// Live LoRaTM modem status.
        /// </summary>
        ModemStat = 0x18,

        /// <summary>
        /// Espimation of last packet SNR.
        /// </summary>
        PktSnrValue = 0x19,

        /// <summary>
        /// RSSI of last packet.
        /// </summary>
        PktRssiValue = 0x1A,

        /// <summary>
        /// Current RSSI.
        /// </summary>
        RssiValue = 0x1B,

        /// <summary>
        /// FHSS start channel.
        /// </summary>
        HopChannel = 0x1C,

        /// <summary>
        /// Modem PHY config 1.
        /// </summary>
        ModemConfig1 = 0x1D,

        /// <summary>
        /// Modem PHY config 2.
        /// </summary>
        ModemConfig2 = 0x1E,

        /// <summary>
        /// Size of preamble.
        /// </summary>
        Preamble = 0x20,

        /// <summary>
        /// LoRa payload length.
        /// </summary>
        PayloadLength = 0x22,

        /// <summary>
        /// LoRa maximum payload length.
        /// </summary>
        MaxPayloadLength = 0x23,

        /// <summary>
        /// FHSS Hop period.
        /// </summary>
        HopPeriod = 0x24,

        /// <summary>
        /// Address of last byte written in FIFO.
        /// </summary>
        FifoRxByteAddr = 0x25,

        /// <summary>
        /// Modem PHY config 3.
        /// </summary>
        ModemConfig3 = 0x26,

        /// <summary>
        /// Estimated frequency error.
        /// </summary>
        Fei = 0x28,

        /// <summary>
        /// Wideband RSSI measurement.
        /// </summary>
        RssiWideband = 0x2C,

        /// <summary>
        /// LoRa detection Optimize for SF6.
        /// </summary>
        DetectOptimize = 0x31,

        /// <summary>
        /// Invert LoRa I and Q signals.
        /// </summary>
        InvertIq = 0x33,

        /// <summary>
        /// LoRa detection threshold for SF6.
        /// </summary>
        DetectionThreshold = 0x37,

        /// <summary>
        /// LoRa Sync Word.
        /// </summary>
        SyncWord = 0x39
    }

    public abstract class LoraRegister : Register
    {
        internal LoraRegister(LoraRegisterAddress address, byte length)
            : base((byte)address, length)
        {
        }
    }

    /// <summary>
    /// FIFO SPI pointer.
    /// </summary>
    [Register((byte)LoraRegisterAddress.FifoAddrPtr, 1)]
    public class LoraRegisterFifoAddrPtr : LoraRegister
    {
        public LoraRegisterFifoAddrPtr(byte value)
            : base(LoraRegisterAddress.FifoAddrPtr, 1)
        {
            // Assigning properties.
            Fifo = value;
        }

        internal LoraRegisterFifoAddrPtr(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterFifoAddrPtr Default = new LoraRegisterFifoAddrPtr(0x00);

        /// <summary>
        /// LoRa base-band FIFO data input/output. FIFO is cleared an not accessible when device is in SLEEP mode.
        /// </summary>
        public byte Fifo { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { Fifo };
        }
    }

    /// <summary>
    /// Start Tx data.
    /// </summary>
    [Register((byte)LoraRegisterAddress.FifoTxBaseAddr, 1)]
    public class LoraRegisterFifoTxBaseAddr : LoraRegister
    {
        public LoraRegisterFifoTxBaseAddr(byte value)
            : base(LoraRegisterAddress.FifoTxBaseAddr, 1)
        {
            // Assigning properties.
            FifoTxBaseAddr = value;
        }

        internal LoraRegisterFifoTxBaseAddr(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterFifoTxBaseAddr Default = new LoraRegisterFifoTxBaseAddr(0x80);

        /// <summary>
        /// Write base address in FIFO data buffer for TX modulator.
        /// </summary>
        public byte FifoTxBaseAddr { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { FifoTxBaseAddr };
        }
    }

    /// <summary>
    /// Start Rx data.
    /// </summary>
    [Register((byte)LoraRegisterAddress.FifoRxBaseAddr, 1)]
    public class LoraRegisterFifoRxBaseAddr : LoraRegister
    {
        public LoraRegisterFifoRxBaseAddr(byte value)
            : base(LoraRegisterAddress.FifoRxBaseAddr, 1)
        {
            // Assigning properties.
            FifoRxBaseAddr = value;
        }

        internal LoraRegisterFifoRxBaseAddr(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterFifoRxBaseAddr Default = new LoraRegisterFifoRxBaseAddr(0x00);

        /// <summary>
        /// Read base address in FIFO data buffer for RX demodulator.
        /// </summary>
        public byte FifoRxBaseAddr { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { FifoRxBaseAddr };
        }
    }

    /// <summary>
    /// Start address of last packet received.
    /// </summary>
    [Register((byte)LoraRegisterAddress.FifoRxCurrentAddr, 1)]
    public class LoraRegisterFifoRxCurrentAddr : LoraRegister
    {
        public LoraRegisterFifoRxCurrentAddr(byte value)
            : base(LoraRegisterAddress.FifoRxCurrentAddr, 1)
        {
            // Assigning properties.
            Addr = value;
        }

        internal LoraRegisterFifoRxCurrentAddr(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Start address (in data buffer) of last packet received.
        /// </summary>
        public byte Addr { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { Addr };
        }
    }

    /// <summary>
    /// Optional IRQ flag mask.
    /// </summary>
    [Register((byte)LoraRegisterAddress.IrqFlagsMask, 1)]
    public class LoraRegisterIrqFlagsMask : LoraRegister
    {
        [Flags]
        public enum FlagsMaskEnum : byte
        {
            None = 0x00,

            /// <summary>
            /// Cad Detected Interrupt Mask: setting this bit masks the corresponding IRQ in RegIrqFlags.
            /// </summary>
            CadDetectedMask = 0x01,

            /// <summary>
            /// FHSS change channel interrupt mask: setting this bit masks the corresponding IRQ in RegIrqFlags.
            /// </summary>
            FhssChangeChannelMask = 0x02,

            /// <summary>
            /// CAD complete interrupt mask: setting this bit masks the corresponding IRQ in RegIrqFlags.
            /// </summary>
            CadDoneMask = 0x04,

            /// <summary>
            /// FIFO Payload transmission complete interrupt mask: setting this bit masks the corresponding IRQ in RegIrqFlags.
            /// </summary>
            TxDoneMask = 0x08,

            /// <summary>
            /// Valid header received in Rx mask: setting this bit masks the corresponding IRQ in RegIrqFlags.
            /// </summary>
            ValidHeaderMask = 0x10,

            /// <summary>
            /// Payload CRC error interrupt mask: setting this bit masks the corresponding IRQ in RegIrqFlags.
            /// </summary>
            PayloadCrcErrorMask = 0x20,

            /// <summary>
            /// Packet reception complete interrupt mask: setting this bit masks the corresponding IRQ in RegIrqFlags.
            /// </summary>
            RxDoneMask = 0x40,

            /// <summary>
            /// Timeout interrupt mask: setting this bit masks the corresponding IRQ in RegIrqFlags.
            /// </summary>
            RxTimeoutMask = 0x80
        }

        public LoraRegisterIrqFlagsMask(
            FlagsMaskEnum flagsMask)
            : base(LoraRegisterAddress.IrqFlagsMask, 1)
        {
            // Assigning properties.
            FlagsMask = flagsMask;
        }

        public LoraRegisterIrqFlagsMask(byte registerValue)
            : base(LoraRegisterAddress.IrqFlagsMask, 1)
        {
            FlagsMask = (FlagsMaskEnum)Enum.ToObject(typeof(FlagsMaskEnum), registerValue);
        }

        internal LoraRegisterIrqFlagsMask(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterIrqFlagsMask Default = new LoraRegisterIrqFlagsMask(FlagsMaskEnum.None);

        public FlagsMaskEnum FlagsMask { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)FlagsMask };
        }
    }

    /// <summary>
    /// IRQ flags.
    /// </summary>
    [Register((byte)LoraRegisterAddress.IrqFlags, 1)]
    public class LoraRegisterIrqFlags : LoraRegister
    {
        [Flags]
        public enum FlagsEnum : byte
        {
            None = 0x00,

            /// <summary>
            /// Valid Lora signal detected during CAD operation: writing a 1 clears the IRQ.
            /// </summary>
            CadDetected = 0x01,

            /// <summary>
            /// FHSS change channel interrupt: writing a 1 clears the IRQ.
            /// </summary>
            FhssChangeChannel = 0x02,

            /// <summary>
            /// CAD complete: write to clear: writing a 1 clears the IRQ.
            /// </summary>
            CadDone = 0x04,

            /// <summary>
            /// FIFO Payload transmission complete interrupt: writing a 1 clears the IRQ.
            /// </summary>
            TxDone = 0x08,

            /// <summary>
            /// Valid header received in Rx: writing a 1 clears the IRQ.
            /// </summary>
            ValidHeader = 0x10,

            /// <summary>
            /// Payload CRC error interrupt: writing a 1 clears the IRQ.
            /// </summary>
            PayloadCrcError = 0x20,

            /// <summary>
            /// Packet reception complete interrupt: writing a 1 clears the IRQ.
            /// </summary>
            RxDone = 0x40,

            /// <summary>
            /// Timeout interrupt: writing a 1 clears the IRQ.
            /// </summary>
            RxTimeout = 0x80
        }

        public LoraRegisterIrqFlags(
            FlagsEnum flags)
            : base(LoraRegisterAddress.IrqFlags, 1)
        {
            // Assigning properties.
            Flags = flags;
        }

        public LoraRegisterIrqFlags(byte registerValue)
            : base(LoraRegisterAddress.IrqFlags, 1)
        {
            Flags = (FlagsEnum)Enum.ToObject(typeof(FlagsEnum), registerValue);
        }

        internal LoraRegisterIrqFlags(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        public FlagsEnum Flags { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)Flags };
        }
    }

    /// <summary>
    /// Number of received bytes.
    /// </summary>
    [Register((byte)LoraRegisterAddress.RxNbBytes, 1)]
    public class LoraRegisterRxNbBytes : LoraRegister
    {
        public LoraRegisterRxNbBytes(byte value)
            : base(LoraRegisterAddress.RxNbBytes, 1)
        {
            // Assigning properties.
            FifoRxBytesNb = value;
        }

        internal LoraRegisterRxNbBytes(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Number of payload bytes of latest packet received.
        /// </summary>
        public byte FifoRxBytesNb { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { FifoRxBytesNb };
        }
    }

    /// <summary>
    /// Number of valid headers received.
    /// </summary>
    [Register((byte)LoraRegisterAddress.RxHeaderCntValue, 2)]
    public class LoraRegisterRxHeaderCntValue : LoraRegister
    {
        public LoraRegisterRxHeaderCntValue(
            ushort validHeaderCnt)
            : base(LoraRegisterAddress.RxHeaderCntValue, 2)
        {
            // Assigning properties.
            ValidHeaderCnt = validHeaderCnt;
        }

        public LoraRegisterRxHeaderCntValue(byte registerValue1, byte registerValue2)
            : base(LoraRegisterAddress.RxHeaderCntValue, 2)
        {
            // Assigning the composed numerical value.
            ValidHeaderCnt = (ushort)((registerValue1 << 8) | registerValue2);
        }

        internal LoraRegisterRxHeaderCntValue(byte[] registerValues)
            : this(registerValues[0], registerValues[1])
        {
        }

        /// <summary>
        /// Number of valid headers received since last transition into Rx mode. Header and packet counters are reseted in Sleep mode.
        /// </summary>
        public ushort ValidHeaderCnt { get; }

        internal override byte[] GetAsBytes()
        {
            return new[]
            {
                (byte)(ValidHeaderCnt >> 8),
                (byte)ValidHeaderCnt
            };
        }
    }

    /// <summary>
    /// Number of valid packets received.
    /// </summary>
    [Register((byte)LoraRegisterAddress.RxPacketCntValue, 2)]
    public class LoraRegisterRxPacketCntValue : LoraRegister
    {
        public LoraRegisterRxPacketCntValue(
            ushort validPacketCnt)
            : base(LoraRegisterAddress.RxPacketCntValue, 2)
        {
            // Assigning properties.
            ValidPacketCnt = validPacketCnt;
        }

        public LoraRegisterRxPacketCntValue(byte registerValue1, byte registerValue2)
            : base(LoraRegisterAddress.RxPacketCntValue, 2)
        {
            // Assigning the composed numerical value.
            ValidPacketCnt = (ushort)((registerValue1 << 8) | registerValue2);
        }

        internal LoraRegisterRxPacketCntValue(byte[] registerValues)
            : this(registerValues[0], registerValues[1])
        {
        }

        /// <summary>
        /// Number of valid packets received since last transition into Rx mode. Header and packet counters are reseted in Sleep mode.
        /// </summary>
        public ushort ValidPacketCnt { get; }

        internal override byte[] GetAsBytes()
        {
            return new[]
            {
                (byte)(ValidPacketCnt >> 8),
                (byte)ValidPacketCnt
            };
        }
    }

    /// <summary>
    /// Live LoRaTM modem status.
    /// </summary>
    [Register((byte)LoraRegisterAddress.ModemStat, 1)]
    public class LoraRegisterModemStat : LoraRegister
    {
        /// <summary>
        /// Coding rate of last header received.
        /// </summary>
        public enum RxCodingRateEnum : byte
        {
            /// <summary>
            /// Value 0.
            /// </summary>
            Value0 = 0x00,

            /// <summary>
            /// Value 1.
            /// </summary>
            Value1 = 0x01,

            /// <summary>
            /// Value 2.
            /// </summary>
            Value2 = 0x02,

            /// <summary>
            /// Value 3.
            /// </summary>
            Value3 = 0x03,

            /// <summary>
            /// Value 4.
            /// </summary>
            Value4 = 0x04,

            /// <summary>
            /// Value 5.
            /// </summary>
            Value5 = 0x05,

            /// <summary>
            /// Value 6.
            /// </summary>
            Value6 = 0x06,

            /// <summary>
            /// Value 7.
            /// </summary>
            Value7 = 0x07
        }

        /// <summary>
        /// The modem status.
        /// </summary>
        [Flags]
        public enum ModemStatusEnum : byte
        {
            None = 0x00,

            /// <summary>
            /// Signal detected.
            /// </summary>
            SignalDetected = 0x01,

            /// <summary>
            /// Signal synchronized.
            /// </summary>
            SignalSynchronized = 0x02,

            /// <summary>
            /// RX on-going.
            /// </summary>
            RxOngoing = 0x04,

            /// <summary>
            /// Header info valid.
            /// </summary>
            HeaderInfoValid = 0x08,

            /// <summary>
            /// Modem clear.
            /// </summary>
            ModemClear = 0x10
        }

        public LoraRegisterModemStat(
            RxCodingRateEnum rxCodingRate,
            ModemStatusEnum modemStatus)
            : base(LoraRegisterAddress.ModemStat, 1)
        {
            // Assigning properties.
            RxCodingRate = rxCodingRate;
            ModemStatus = modemStatus;
        }

        public LoraRegisterModemStat(byte registerValue)
            : base(LoraRegisterAddress.ModemStat, 1)
        {
            RxCodingRate = (RxCodingRateEnum)Enum.ToObject(typeof(RxCodingRateEnum), (byte)((registerValue & 0xE0) >> 5));
            ModemStatus = (ModemStatusEnum)Enum.ToObject(typeof(ModemStatusEnum), (byte)(registerValue & 0x1F));
        }

        internal LoraRegisterModemStat(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Coding rate of last header received.
        /// </summary>
        public RxCodingRateEnum RxCodingRate { get; }

        /// <summary>
        /// The modem status.
        /// </summary>
        public ModemStatusEnum ModemStatus { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)RxCodingRate << 5) & 0xE0) | (byte)((byte)ModemStatus & 0x1F)) };
        }
    }

    /// <summary>
    /// Espimation of last packet SNR.
    /// </summary>
    [Register((byte)LoraRegisterAddress.PktSnrValue, 1)]
    public class LoraRegisterPktSnrValue : LoraRegister
    {
        public LoraRegisterPktSnrValue(byte value)
            : base(LoraRegisterAddress.PktSnrValue, 1)
        {
            // Assigning properties.
            PacketSnr = value;
        }

        internal LoraRegisterPktSnrValue(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Estimation of SNR on last packet received. In two’s compliment format mutiplied by 4. Formula: SNR[dB] = PacketSnr[twos complement] / 4.
        /// </summary>
        public byte PacketSnr { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { PacketSnr };
        }
    }

    /// <summary>
    /// RSSI of last packet.
    /// </summary>
    [Register((byte)LoraRegisterAddress.PktRssiValue, 1)]
    public class LoraRegisterPktRssiValue : LoraRegister
    {
        public LoraRegisterPktRssiValue(byte value)
            : base(LoraRegisterAddress.PktRssiValue, 1)
        {
            // Assigning properties.
            PacketRssi = value;
        }

        internal LoraRegisterPktRssiValue(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// RSSI of the latest packet received (dBm): RSSI[dBm] = -157 + Rssi (using HF output port, SNR >= 0) or RSSI[dBm] = -164 + Rssi (using LF output port, SNR >= 0).
        /// </summary>
        public byte PacketRssi { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { PacketRssi };
        }
    }

    /// <summary>
    /// Current RSSI.
    /// </summary>
    [Register((byte)LoraRegisterAddress.RssiValue, 1)]
    public class LoraRegisterRssiValue : LoraRegister
    {
        public LoraRegisterRssiValue(byte value)
            : base(LoraRegisterAddress.RssiValue, 1)
        {
            // Assigning properties.
            Rssi = value;
        }

        internal LoraRegisterRssiValue(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Current RSSI value (dBm): RSSI[dBm] = -157 + Rssi (using HF output port) or RSSI[dBm] = -164 + Rssi (using LF output port).
        /// </summary>
        public byte Rssi { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { Rssi };
        }
    }

    /// <summary>
    /// FHSS start channel.
    /// </summary>
    [Register((byte)LoraRegisterAddress.HopChannel, 1)]
    public class LoraRegisterHopChannel : LoraRegister
    {
        /// <summary>
        /// PLL failed to lock while attempting a TX/RX/CAD operation.
        /// </summary>
        public enum PllTimeoutEnum : byte
        {
            /// <summary>
            /// Normal mode, a single packet is sent.
            /// </summary>
            PllDidNotLock = 0x00,

            /// <summary>
            /// Continuous mode, send multiple packets across the FIFO (used for spectral analysis).
            /// </summary>
            PllDidLock = 0x01
        }

        /// <summary>
        /// CRC Information extracted from the received packet header (Explicit header mode only).
        /// </summary>
        public enum CrcOnPayloadEnum : byte
        {
            /// <summary>
            /// Header indicates CRC off.
            /// </summary>
            HeaderIndicatesCrcOff = 0x00,

            /// <summary>
            /// Header indicates CRC on.
            /// </summary>
            HeaderIndicatesCrcOn = 0x01
        }

        /// <summary>
        /// Current value of frequency hopping channel in use.
        /// </summary>
        public enum FhssPresentChannelEnum : byte
        {
            /// <summary>
            /// Channel 0.
            /// </summary>
            Channel00 = 0x00,

            /// <summary>
            /// Channel 1.
            /// </summary>
            Channel01 = 0x01,

            /// <summary>
            /// Channel 2.
            /// </summary>
            Channel02 = 0x02,

            /// <summary>
            /// Channel 3.
            /// </summary>
            Channel03 = 0x03,

            /// <summary>
            /// Channel 4.
            /// </summary>
            Channel04 = 0x04,

            /// <summary>
            /// Channel 5.
            /// </summary>
            Channel05 = 0x05,

            /// <summary>
            /// Channel 6.
            /// </summary>
            Channel06 = 0x06,

            /// <summary>
            /// Channel 7.
            /// </summary>
            Channel07 = 0x07,

            /// <summary>
            /// Channel 8.
            /// </summary>
            Channel08 = 0x08,

            /// <summary>
            /// Channel 9.
            /// </summary>
            Channel09 = 0x09,

            /// <summary>
            /// Channel 10.
            /// </summary>
            Channel10 = 0x0A,

            /// <summary>
            /// Channel 11.
            /// </summary>
            Channel11 = 0x0B,

            /// <summary>
            /// Channel 12.
            /// </summary>
            Channel12 = 0x0C,

            /// <summary>
            /// Channel 13.
            /// </summary>
            Channel13 = 0x0D,

            /// <summary>
            /// Channel 14.
            /// </summary>
            Channel14 = 0x0E,

            /// <summary>
            /// Channel 15.
            /// </summary>
            Channel15 = 0x0F,

            /// <summary>
            /// Channel 16.
            /// </summary>
            Channel16 = 0x10,

            /// <summary>
            /// Channel 17.
            /// </summary>
            Channel17 = 0x11,

            /// <summary>
            /// Channel 18.
            /// </summary>
            Channel18 = 0x12,

            /// <summary>
            /// Channel 19.
            /// </summary>
            Channel19 = 0x13,

            /// <summary>
            /// Channel 20.
            /// </summary>
            Channel20 = 0x14,

            /// <summary>
            /// Channel 21.
            /// </summary>
            Channel21 = 0x15,

            /// <summary>
            /// Channel 22.
            /// </summary>
            Channel22 = 0x16,

            /// <summary>
            /// Channel 23.
            /// </summary>
            Channel23 = 0x17,

            /// <summary>
            /// Channel 24.
            /// </summary>
            Channel24 = 0x18,

            /// <summary>
            /// Channel 25.
            /// </summary>
            Channel25 = 0x19,

            /// <summary>
            /// Channel 26.
            /// </summary>
            Channel26 = 0x1A,

            /// <summary>
            /// Channel 27.
            /// </summary>
            Channel27 = 0x1B,

            /// <summary>
            /// Channel 28.
            /// </summary>
            Channel28 = 0x1C,

            /// <summary>
            /// Channel 29.
            /// </summary>
            Channel29 = 0x1D,

            /// <summary>
            /// Channel 30.
            /// </summary>
            Channel30 = 0x1E,

            /// <summary>
            /// Channel 31.
            /// </summary>
            Channel31 = 0x1F,

            /// <summary>
            /// Channel 32.
            /// </summary>
            Channel32 = 0x20,

            /// <summary>
            /// Channel 33.
            /// </summary>
            Channel33 = 0x21,

            /// <summary>
            /// Channel 34.
            /// </summary>
            Channel34 = 0x22,

            /// <summary>
            /// Channel 35.
            /// </summary>
            Channel35 = 0x23,

            /// <summary>
            /// Channel 36.
            /// </summary>
            Channel36 = 0x24,

            /// <summary>
            /// Channel 37.
            /// </summary>
            Channel37 = 0x25,

            /// <summary>
            /// Channel 38.
            /// </summary>
            Channel38 = 0x26,

            /// <summary>
            /// Channel 39.
            /// </summary>
            Channel39 = 0x27,

            /// <summary>
            /// Channel 40.
            /// </summary>
            Channel40 = 0x28,

            /// <summary>
            /// Channel 41.
            /// </summary>
            Channel41 = 0x29,

            /// <summary>
            /// Channel 42.
            /// </summary>
            Channel42 = 0x2A,

            /// <summary>
            /// Channel 43.
            /// </summary>
            Channel43 = 0x2B,

            /// <summary>
            /// Channel 44.
            /// </summary>
            Channel44 = 0x2C,

            /// <summary>
            /// Channel 45.
            /// </summary>
            Channel45 = 0x2D,

            /// <summary>
            /// Channel 46.
            /// </summary>
            Channel46 = 0x2E,

            /// <summary>
            /// Channel 47.
            /// </summary>
            Channel47 = 0x2F,

            /// <summary>
            /// Channel 48.
            /// </summary>
            Channel48 = 0x30,

            /// <summary>
            /// Channel 49.
            /// </summary>
            Channel49 = 0x31,

            /// <summary>
            /// Channel 50.
            /// </summary>
            Channel50 = 0x32,

            /// <summary>
            /// Channel 51.
            /// </summary>
            Channel51 = 0x33,

            /// <summary>
            /// Channel 52.
            /// </summary>
            Channel52 = 0x34,

            /// <summary>
            /// Channel 53.
            /// </summary>
            Channel53 = 0x35,

            /// <summary>
            /// Channel 54.
            /// </summary>
            Channel54 = 0x36,

            /// <summary>
            /// Channel 55.
            /// </summary>
            Channel55 = 0x37,

            /// <summary>
            /// Channel 56.
            /// </summary>
            Channel56 = 0x38,

            /// <summary>
            /// Channel 57.
            /// </summary>
            Channel57 = 0x39,

            /// <summary>
            /// Channel 58.
            /// </summary>
            Channel58 = 0x3A,

            /// <summary>
            /// Channel 59.
            /// </summary>
            Channel59 = 0x3B,

            /// <summary>
            /// Channel 60.
            /// </summary>
            Channel60 = 0x3C,

            /// <summary>
            /// Channel 61.
            /// </summary>
            Channel61 = 0x3D,

            /// <summary>
            /// Channel 62.
            /// </summary>
            Channel62 = 0x3E,

            /// <summary>
            /// Channel 63.
            /// </summary>
            Channel63 = 0x3F
        }

        public LoraRegisterHopChannel(
            PllTimeoutEnum pllTimeout,
            CrcOnPayloadEnum crcOnPayload,
            FhssPresentChannelEnum fhssPresentChannel)
            : base(LoraRegisterAddress.HopChannel, 1)
        {
            // Assigning properties.
            PllTimeout = pllTimeout;
            CrcOnPayload = crcOnPayload;
            FhssPresentChannel = fhssPresentChannel;
        }

        public LoraRegisterHopChannel(byte registerValue)
            : base(LoraRegisterAddress.HopChannel, 1)
        {
            PllTimeout = (PllTimeoutEnum)Enum.ToObject(typeof(PllTimeoutEnum), (byte)((registerValue & 0x80) >> 7));
            CrcOnPayload = (CrcOnPayloadEnum)Enum.ToObject(typeof(CrcOnPayloadEnum), (byte)((registerValue & 0x40) >> 6));
            FhssPresentChannel = (FhssPresentChannelEnum)Enum.ToObject(typeof(FhssPresentChannelEnum), (byte)(registerValue & 0x3F));
        }

        internal LoraRegisterHopChannel(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// PLL failed to lock while attempting a TX/RX/CAD operation.
        /// </summary>
        public PllTimeoutEnum PllTimeout { get; }

        /// <summary>
        /// CRC Information extracted from the received packet header (Explicit header mode only).
        /// </summary>
        public CrcOnPayloadEnum CrcOnPayload { get; }

        /// <summary>
        /// Current value of frequency hopping channel in use.
        /// </summary>
        public FhssPresentChannelEnum FhssPresentChannel { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)PllTimeout << 7) & 0x80) | (byte)(((byte)CrcOnPayload << 6) & 0x40) | (byte)((byte)FhssPresentChannel & 0x3F)) };
        }
    }

    /// <summary>
    /// Modem PHY config 1.
    /// </summary>
    [Register((byte)LoraRegisterAddress.ModemConfig1, 1)]
    public class LoraRegisterModemConfig1 : LoraRegister
    {
        /// <summary>
        /// TX mode.
        /// </summary>
        public enum BandWidthEnum : byte
        {
            /// <summary>
            /// BandWidth 7.8 kHz.
            /// </summary>
            BandWidth_007_80_kHz = 0x00,

            /// <summary>
            /// BandWidth 10.5 kHz.
            /// </summary>
            BandWidth_010_40_kHz = 0x01,

            /// <summary>
            /// BandWidth 15.6 kHz.
            /// </summary>
            BandWidth_015_60_kHz = 0x02,

            /// <summary>
            /// BandWidth 20.8 kHz.
            /// </summary>
            BandWidth_020_80_kHz = 0x03,

            /// <summary>
            /// BandWidth 31.25 kHz.
            /// </summary>
            BandWidth_031_25_kHz = 0x04,

            /// <summary>
            /// BandWidth 41.7 kHz.
            /// </summary>
            BandWidth_041_70_kHz = 0x05,

            /// <summary>
            /// BandWidth 62.5 kHz.
            /// </summary>
            BandWidth_062_50_kHz = 0x06,

            /// <summary>
            /// BandWidth 125 kHz.
            /// </summary>
            BandWidth_125_00_kHz = 0x07,

            /// <summary>
            /// BandWidth 250 kHz.
            /// </summary>
            BandWidth_250_00_kHz = 0x08,

            /// <summary>
            /// BandWidth 500 kHz.
            /// </summary>
            BandWidth_500_00_kHz = 0x09
        }

        /// <summary>
        /// Error coding rate.
        /// </summary>
        public enum CodingRateEnum : byte
        {
            /// <summary>
            /// Error coding rate 4/5.
            /// </summary>
            Rate1 = 0x01,

            /// <summary>
            /// Error coding rate 4/6.
            /// </summary>
            Rate2 = 0x02,

            /// <summary>
            /// Error coding rate 4/7.
            /// </summary>
            Rate3 = 0x03,

            /// <summary>
            /// Error coding rate 4/8.
            /// </summary>
            Rate4 = 0x04
        }

        /// <summary>
        /// Header mode.
        /// </summary>
        public enum HeaderModeEnum : byte
        {
            /// <summary>
            /// Explicit Header mode.
            /// </summary>
            ExplicitHeaderMode = 0x00,

            /// <summary>
            /// Implicit Header mode.
            /// </summary>
            ImplicitHeaderMode = 0x01
        }

        public LoraRegisterModemConfig1(
            BandWidthEnum bandWidth,
            CodingRateEnum codingRate,
            HeaderModeEnum headerMode)
            : base(LoraRegisterAddress.ModemConfig1, 1)
        {
            // Assigning properties.
            BandWidth = bandWidth;
            CodingRate = codingRate;
            HeaderMode = headerMode;
        }

        public LoraRegisterModemConfig1(byte registerValue)
            : base(LoraRegisterAddress.ModemConfig1, 1)
        {
            BandWidth = (BandWidthEnum)Enum.ToObject(typeof(BandWidthEnum), (byte)((registerValue & 0xF0) >> 4));
            CodingRate = (CodingRateEnum)Enum.ToObject(typeof(CodingRateEnum), (byte)((registerValue & 0x0E) >> 1));
            HeaderMode = (HeaderModeEnum)Enum.ToObject(typeof(HeaderModeEnum), (byte)(registerValue & 0x01));
        }

        internal LoraRegisterModemConfig1(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterModemConfig1 Default = new LoraRegisterModemConfig1(
            BandWidthEnum.BandWidth_125_00_kHz,
            CodingRateEnum.Rate1,
            HeaderModeEnum.ExplicitHeaderMode);

        /// <summary>
        /// TX mode.
        /// </summary>
        public BandWidthEnum BandWidth { get; }

        /// <summary>
        /// Error coding rate.
        /// </summary>
        public CodingRateEnum CodingRate { get; }

        /// <summary>
        /// Header mode.
        /// </summary>
        public HeaderModeEnum HeaderMode { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)BandWidth << 4) & 0xF0) | (byte)(((byte)CodingRate << 1) & 0x0E) | (byte)((byte)HeaderMode & 0x01)) };
        }
    }

    /// <summary>
    /// Modem PHY config 2.
    /// </summary>
    [Register((byte)LoraRegisterAddress.ModemConfig2, 2)]
    public class LoraRegisterModemConfig2 : LoraRegister
    {
        /// <summary>
        /// SF rate (expressed as a base-2 logarithm).
        /// </summary>
        public enum SpreadingFactorEnum : byte
        {
            /// <summary>
            /// 64 chips / symbol.
            /// </summary>
            Sf_0064_ChipsPerSymbol = 0x06,

            /// <summary>
            /// 128 chips / symbol.
            /// </summary>
            Sf_0128_ChipsPerSymbol = 0x07,

            /// <summary>
            /// 256 chips / symbol.
            /// </summary>
            Sf_0256_ChipsPerSymbol = 0x08,

            /// <summary>
            /// 512 chips / symbol.
            /// </summary>
            Sf_0512_ChipsPerSymbol = 0x09,

            /// <summary>
            /// 1024 chips / symbol.
            /// </summary>
            Sf_1024_ChipsPerSymbol = 0x0A,

            /// <summary>
            /// 2048 chips / symbol.
            /// </summary>
            Sf_2048_ChipsPerSymbol = 0x0B,

            /// <summary>
            /// 4096 chips / symbol.
            /// </summary>
            Sf_4096_ChipsPerSymbol = 0x0C
        }

        /// <summary>
        /// TX mode.
        /// </summary>
        public enum TxModeEnum : byte
        {
            /// <summary>
            /// Normal mode, a single packet is sent.
            /// </summary>
            NormalMode = 0x00,

            /// <summary>
            /// Continuous mode, send multiple packets across the FIFO (used for spectral analysis).
            /// </summary>
            ContinuousMode = 0x01
        }

        /// <summary>
        /// Enable CRC generation and check on payload.
        /// If CRC is needed, RxPayloadCrcOn should be set:
        /// - in Implicit header mode: on Tx and Rx side.
        /// - in Explicit header mode: on the Tx side alone (recovered from the header in Rx side).
        /// </summary>
        public enum RxPayloadCrcEnum : byte
        {
            /// <summary>
            /// CRC disable.
            /// </summary>
            CrcDisabled = 0x00,

            /// <summary>
            /// CRC enable.
            /// </summary>
            CrcEnabled = 0x01
        }

        public LoraRegisterModemConfig2(
            SpreadingFactorEnum spreadingFactor,
            TxModeEnum txMode,
            RxPayloadCrcEnum rxPayloadCrc,
            ushort symbolTimeout)
            : base(LoraRegisterAddress.ModemConfig2, 2)
        {
            // Validating the numerical range.
            if (symbolTimeout > 0x3FF)
            {
                throw new ArgumentException($"{nameof(symbolTimeout)} must be in the range of [0x000 - 0x3FF].");
            }

            // Assigning properties.
            SpreadingFactor = spreadingFactor;
            TxMode = txMode;
            RxPayloadCrc = rxPayloadCrc;
            SymbolTimeout = symbolTimeout;
        }

        public LoraRegisterModemConfig2(byte registerValue1, byte registerValue2)
            : base(LoraRegisterAddress.ModemConfig2, 2)
        {
            SpreadingFactor = (SpreadingFactorEnum)Enum.ToObject(typeof(SpreadingFactorEnum), (byte)((registerValue1 & 0xF0) >> 4));
            TxMode = (TxModeEnum)Enum.ToObject(typeof(TxModeEnum), (byte)((registerValue1 & 0x08) >> 3));
            RxPayloadCrc = (RxPayloadCrcEnum)Enum.ToObject(typeof(RxPayloadCrcEnum), (byte)((registerValue1 & 0x04) >> 2));
            // Assigning the composed numerical value.
            SymbolTimeout = (ushort)(((registerValue1 & 0x03) << 8) | registerValue2);
        }

        internal LoraRegisterModemConfig2(byte[] registerValues)
            : this(registerValues[0], registerValues[1])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterModemConfig2 Default = new LoraRegisterModemConfig2(
            SpreadingFactorEnum.Sf_0128_ChipsPerSymbol,
            TxModeEnum.NormalMode,
            RxPayloadCrcEnum.CrcDisabled,
            0x064);

        /// <summary>
        /// SF rate (expressed as a base-2 logarithm).
        /// </summary>
        public SpreadingFactorEnum SpreadingFactor { get; }

        /// <summary>
        /// TX mode.
        /// </summary>
        public TxModeEnum TxMode { get; }

        /// <summary>
        /// Enable CRC generation and check on payload.
        /// If CRC is needed, RxPayloadCrcOn should be set:
        /// - in Implicit header mode: on Tx and Rx side.
        /// - in Explicit header mode: on the Tx side alone (recovered from the header in Rx side).
        /// </summary>
        public RxPayloadCrcEnum RxPayloadCrc { get; }

        /// <summary>
        /// RX operation time-out value expressed as number of symbols. Time-out = <see cref="SymbolTimeout"/> * Ts. A value between 0 and 1023.
        /// </summary>
        public ushort SymbolTimeout { get; }

        internal override byte[] GetAsBytes()
        {
            return new[]
            {
                (byte)((byte)(((byte)SpreadingFactor << 4) & 0xF0) | (byte)(((byte)TxMode << 3) & 0x08) | (byte)(((byte)RxPayloadCrc << 2) & 0x04) | (byte)((SymbolTimeout >> 8) & 0x03)),
                (byte)SymbolTimeout
            };
        }
    }

    /// <summary>
    /// Size of preamble.
    /// </summary>
    [Register((byte)LoraRegisterAddress.Preamble, 2)]
    public class LoraRegisterPreamble : LoraRegister
    {
        public LoraRegisterPreamble(
            ushort preambleLength)
            : base(LoraRegisterAddress.Preamble, 2)
        {
            // Assigning properties.
            PreambleLength = preambleLength;
        }

        public LoraRegisterPreamble(byte registerValue1, byte registerValue2)
            : base(LoraRegisterAddress.Preamble, 2)
        {
            // Assigning the composed numerical value.
            PreambleLength = (ushort)((registerValue1 << 8) | registerValue2);
        }

        internal LoraRegisterPreamble(byte[] registerValues)
            : this(registerValues[0], registerValues[1])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterPreamble Default = new LoraRegisterPreamble(0x0008);

        /// <summary>
        /// Preamble length MSB, = PreambleLength + 4.25 Symbols.
        /// </summary>
        public ushort PreambleLength { get; }

        internal override byte[] GetAsBytes()
        {
            return new[]
            {
                (byte)(PreambleLength >> 8),
                (byte)PreambleLength
            };
        }
    }

    /// <summary>
    /// LoRa payload length.
    /// </summary>
    [Register((byte)LoraRegisterAddress.PayloadLength, 1)]
    public class LoraRegisterPayloadLength : LoraRegister
    {
        public LoraRegisterPayloadLength(byte value)
            : base(LoraRegisterAddress.PayloadLength, 1)
        {
            // Assigning properties.
            PayloadLength = value;
        }

        internal LoraRegisterPayloadLength(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterPayloadLength Default = new LoraRegisterPayloadLength(0x01);

        /// <summary>
        /// Payload length in bytes. The register needs to be set in implicit header mode for the expected packet length. A 0 value is not permitted.
        /// </summary>
        public byte PayloadLength { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { PayloadLength };
        }
    }

    /// <summary>
    /// LoRa maximum payload length.
    /// </summary>
    [Register((byte)LoraRegisterAddress.MaxPayloadLength, 1)]
    public class LoraRegisterMaxPayloadLength : LoraRegister
    {
        public LoraRegisterMaxPayloadLength(byte value)
            : base(LoraRegisterAddress.MaxPayloadLength, 1)
        {
            // Assigning properties.
            MaxPayloadLength = value;
        }

        internal LoraRegisterMaxPayloadLength(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterMaxPayloadLength Default = new LoraRegisterMaxPayloadLength(0xFF);

        /// <summary>
        /// Maximum payload length; if header payload length exceeds value a header CRC error is generated. Allows filtering of packet with a bad size.
        /// </summary>
        public byte MaxPayloadLength { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { MaxPayloadLength };
        }
    }

    /// <summary>
    /// FHSS Hop period.
    /// </summary>
    [Register((byte)LoraRegisterAddress.HopPeriod, 1)]
    public class LoraRegisterHopPeriod : LoraRegister
    {
        public LoraRegisterHopPeriod(byte value)
            : base(LoraRegisterAddress.HopPeriod, 1)
        {
            // Assigning properties.
            FreqHoppingPeriod = value;
        }

        internal LoraRegisterHopPeriod(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterHopPeriod Default = new LoraRegisterHopPeriod(0x00);

        /// <summary>
        /// Symbol periods between frequency hops. (0 = disabled). 1st hop always happen after the 1st header symbol.
        /// </summary>
        public byte FreqHoppingPeriod { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { FreqHoppingPeriod };
        }
    }

    /// <summary>
    /// Address of last byte written in FIFO.
    /// </summary>
    [Register((byte)LoraRegisterAddress.FifoRxByteAddr, 1)]
    public class LoraRegisterFifoRxByteAddr : LoraRegister
    {
        public LoraRegisterFifoRxByteAddr(byte value)
            : base(LoraRegisterAddress.FifoRxByteAddr, 1)
        {
            // Assigning properties.
            FifoRxByteAddrPtr = value;
        }

        internal LoraRegisterFifoRxByteAddr(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Current value of RX databuffer pointer (address of last byte written by Lora receiver).
        /// </summary>
        public byte FifoRxByteAddrPtr { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { FifoRxByteAddrPtr };
        }
    }

    /// <summary>
    /// Modem PHY config 3.
    /// </summary>
    [Register((byte)LoraRegisterAddress.ModemConfig3, 1)]
    public class LoraRegisterModemConfig3 : LoraRegister
    {
        /// <summary>
        /// Low data rate optimize.
        /// </summary>
        public enum LowDataRateOptimizeEnum : byte
        {
            /// <summary>
            /// Disabled.
            /// </summary>
            Disabled = 0x00,

            /// <summary>
            /// Enabled; mandated for when the symbol length exceeds 16ms.
            /// </summary>
            Enabled = 0x01
        }

        /// <summary>
        /// Low data rate optimize.
        /// </summary>
        public enum AgcAutoEnum : byte
        {
            /// <summary>
            /// LNA gain set by register <see cref="CommonRegisterLna.LnaGain"/>.
            /// </summary>
            Disabled = 0x00,

            /// <summary>
            /// LNA gain set by the internal AGC loop.
            /// </summary>
            Enabled = 0x01
        }

        public LoraRegisterModemConfig3(
            LowDataRateOptimizeEnum lowDataRateOptimize,
            AgcAutoEnum agcAuto)
            : base(LoraRegisterAddress.ModemConfig3, 1)
        {
            // Assigning properties.
            LowDataRateOptimize = lowDataRateOptimize;
            AgcAuto = agcAuto;
        }

        public LoraRegisterModemConfig3(byte registerValue)
            : base(LoraRegisterAddress.ModemConfig3, 1)
        {
            LowDataRateOptimize = (LowDataRateOptimizeEnum)Enum.ToObject(typeof(LowDataRateOptimizeEnum), (byte)((registerValue & 0x08) >> 3));
            AgcAuto = (AgcAutoEnum)Enum.ToObject(typeof(AgcAutoEnum), (byte)((registerValue & 0x04) >> 2));
        }

        internal LoraRegisterModemConfig3(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterModemConfig3 Default = new LoraRegisterModemConfig3(
            LowDataRateOptimizeEnum.Disabled,
            AgcAutoEnum.Disabled);

        /// <summary>
        /// Low data rate optimize.
        /// </summary>
        public LowDataRateOptimizeEnum LowDataRateOptimize { get; }

        /// <summary>
        /// Low data rate optimize.
        /// </summary>
        public AgcAutoEnum AgcAuto { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)(((byte)LowDataRateOptimize << 3) & 0x08) | (byte)(((byte)AgcAuto << 2) & 0x04)) };
        }
    }

    /// <summary>
    /// Estimated frequency error.
    /// </summary>
    [Register((byte)LoraRegisterAddress.Fei, 3)]
    public class LoraRegisterFei : LoraRegister
    {
        public LoraRegisterFei(
            uint freqError)
            : base(LoraRegisterAddress.Fei, 3)
        {
            // Validating the numerical range.
            if (freqError > 0xFFFFF)
            {
                throw new ArgumentException($"{nameof(freqError)} must be in the range of [0x00000 - 0xFFFFF].");
            }

            // Assigning properties.
            FreqError = freqError;
        }

        public LoraRegisterFei(byte registerValue1, byte registerValue2, byte registerValue3)
            : base(LoraRegisterAddress.Fei, 3)
        {
            // Assigning the composed numerical value.
            FreqError = (uint)(((registerValue1 & 0x0F) << 16) | (registerValue2 << 8) | registerValue3);
        }

        internal LoraRegisterFei(byte[] registerValues)
            : this(registerValues[0], registerValues[1], registerValues[2])
        {
        }

        /// <summary>
        /// Estimated frequency error from modem MSB of RF Frequency Error. Formula: F[error] = ((FreqError x 2^24) / F[xtal]) x (BW[kHz] / 500).
        /// </summary>
        public uint FreqError { get; }

        internal override byte[] GetAsBytes()
        {
            return new[]
            {
                (byte)((FreqError >> 16) & 0x0F),
                (byte)(FreqError >> 8),
                (byte)FreqError
            };
        }
    }

    /// <summary>
    /// Wideband RSSI measurement.
    /// </summary>
    [Register((byte)LoraRegisterAddress.RssiWideband, 1)]
    public class LoraRegisterRssiWideband : LoraRegister
    {
        public LoraRegisterRssiWideband(byte value)
            : base(LoraRegisterAddress.RssiWideband, 1)
        {
            // Assigning properties.
            RssiWideband = value;
        }

        internal LoraRegisterRssiWideband(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Wideband RSSI measurement used to locally generate a random number.
        /// </summary>
        public byte RssiWideband { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { RssiWideband };
        }
    }

    /// <summary>
    /// LoRa detection Optimize for SF6.
    /// </summary>
    [Register((byte)LoraRegisterAddress.DetectOptimize, 1)]
    public class LoraRegisterDetectOptimize : LoraRegister
    {
        /// <summary>
        /// LoRa detection optimize.
        /// </summary>
        public enum DetectionOptimizeEnum : byte
        {
            /// <summary>
            /// SF7 to SF12.
            /// </summary>
            Sf7ToSf12 = 0x03,

            /// <summary>
            /// SF6.
            /// </summary>
            Sf6 = 0x05
        }

        public LoraRegisterDetectOptimize(
            DetectionOptimizeEnum detectionOptimize)
            : base(LoraRegisterAddress.DetectOptimize, 1)
        {
            // Assigning properties.
            DetectionOptimize = detectionOptimize;
        }

        public LoraRegisterDetectOptimize(byte registerValue)
            : base(LoraRegisterAddress.DetectOptimize, 1)
        {
            DetectionOptimize = (DetectionOptimizeEnum)Enum.ToObject(typeof(DetectionOptimizeEnum), (byte)(registerValue & 0x07));
        }

        internal LoraRegisterDetectOptimize(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterDetectOptimize Default = new LoraRegisterDetectOptimize(DetectionOptimizeEnum.Sf7ToSf12);

        /// <summary>
        /// LoRa detection optimize.
        /// </summary>
        public DetectionOptimizeEnum DetectionOptimize { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)((byte)DetectionOptimize & 0x07) };
        }
    }

    /// <summary>
    /// Invert LoRa I and Q signals.
    /// </summary>
    [Register((byte)LoraRegisterAddress.InvertIq, 1)]
    public class LoraRegisterInvertIq : LoraRegister
    {
        /// <summary>
        /// Invert the LoRa I and Q signals.
        /// </summary>
        public enum InvertIqEnum : byte
        {
            /// <summary>
            /// Normal mode.
            /// </summary>
            NormalMode = 0x00,

            /// <summary>
            /// I and Q signals are inverted.
            /// </summary>
            InvertIq = 0x01
        }

        public LoraRegisterInvertIq(
            InvertIqEnum invertIq)
            : base(LoraRegisterAddress.InvertIq, 1)
        {
            // Assigning properties.
            InvertIq = invertIq;
        }

        public LoraRegisterInvertIq(byte registerValue)
            : base(LoraRegisterAddress.InvertIq, 1)
        {
            InvertIq = (InvertIqEnum)Enum.ToObject(typeof(InvertIqEnum), (byte)((registerValue & 0x40) >> 6));
        }

        internal LoraRegisterInvertIq(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterInvertIq Default = new LoraRegisterInvertIq(InvertIqEnum.NormalMode);

        /// <summary>
        /// Invert the LoRa I and Q signals.
        /// </summary>
        public InvertIqEnum InvertIq { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)(((byte)InvertIq << 6) & 0x40) };
        }
    }

    /// <summary>
    /// LoRa detection threshold for SF6.
    /// </summary>
    [Register((byte)LoraRegisterAddress.DetectionThreshold, 1)]
    public class LoraRegisterDetectionThreshold : LoraRegister
    {
        /// <summary>
        /// LoRa detection threshold.
        /// </summary>
        public enum DetectionThresholdEnum : byte
        {
            /// <summary>
            /// SF7 to SF12.
            /// </summary>
            Sf7ToSf12 = 0x0A,

            /// <summary>
            /// SF6.
            /// </summary>
            Sf6 = 0x0C
        }

        public LoraRegisterDetectionThreshold(
            DetectionThresholdEnum detectionThreshold)
            : base(LoraRegisterAddress.DetectionThreshold, 1)
        {
            // Assigning properties.
            DetectionThreshold = detectionThreshold;
        }

        public LoraRegisterDetectionThreshold(byte registerValue)
            : base(LoraRegisterAddress.DetectionThreshold, 1)
        {
            DetectionThreshold = (DetectionThresholdEnum)Enum.ToObject(typeof(DetectionThresholdEnum), registerValue);
        }

        internal LoraRegisterDetectionThreshold(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterDetectionThreshold Default = new LoraRegisterDetectionThreshold(DetectionThresholdEnum.Sf7ToSf12);

        /// <summary>
        /// LoRa detection threshold.
        /// </summary>
        public DetectionThresholdEnum DetectionThreshold { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { (byte)DetectionThreshold };
        }
    }

    /// <summary>
    /// LoRa Sync Word.
    /// </summary>
    [Register((byte)LoraRegisterAddress.SyncWord, 1)]
    public class LoraRegisterSyncWord : LoraRegister
    {
        public LoraRegisterSyncWord(byte value)
            : base(LoraRegisterAddress.SyncWord, 1)
        {
            // Assigning properties.
            SyncWord = value;
        }

        internal LoraRegisterSyncWord(byte[] registerValues)
            : this(registerValues[0])
        {
        }

        /// <summary>
        /// Reset values.
        /// </summary>
        public static readonly LoraRegisterSyncWord Default = new LoraRegisterSyncWord(0x12);

        /// <summary>
        /// LoRa Sync Word. Value 0x34 is reserved for LoRaWAN networks.
        /// </summary>
        public byte SyncWord { get; }

        internal override byte[] GetAsBytes()
        {
            return new[] { SyncWord };
        }
    }
}
